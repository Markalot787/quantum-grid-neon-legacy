This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-05T20:58:10.269Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.cursor/docs/developmentplan.md
.cursor/docs/enhancments.md
.cursor/docs/GameAesthetics.md
.cursor/docs/gamerules.md
.cursor/docs/Intelligence Cube 3D - Complete Game Implementation.md
.cursor/docs/MVP part2.md
.cursor/docs/Node.js Express Server and Deployment Guide.md
.cursor/docs/update1.md
.gitignore
deploy.ps1
package.json
public/game/Cube.js
public/game/Game.js
public/game/Level.js
public/game/main.js
public/game/PaymentModal.js
public/game/Player.js
public/game/UI.js
public/index.html
public/main.js
public/success.html
README.md
server.js

================================================================
Repository Files
================================================================

================
File: .cursor/docs/developmentplan.md
================
Got it! I'll create a detailed plan for developing an infinite-level version of I.Q.: Intelligent Qube in Three.js, focusing entirely on 100% Flow Mechanics to ensure seamless and engaging gameplay.

- The game will feature an **Infinite Level Builder** with procedural generation that scales difficulty dynamically to maintain flow.
- I'll incorporate **Game Additions & Twists** to enhance flow, including new mechanics, power-ups, and adaptive stage elements.
- The design will be **modernized** while maintaining the spirit of the original.
- I'll outline **Three.js implementation**, covering cube physics, player movement, and collision detection.
- Multiplayer support will include **leaderboards, co-op, and competitive play.**

I'll get back to you with a comprehensive development roadmap!

# Infinite Level Builder

- **Procedural Generation Algorithm**: Implement a robust procedural generation system to create never-ending sequences of cube configurations. The level builder should _continuously spawn new floor sections and puzzle patterns_ as the player progresses, essentially creating an endless level that “grows” as the player advances ([A new game: Hyperspeed!. How about a little web-based runner…](https://medium.com/geekculture/a-new-game-hyperspeed-e3fb5701d90f#:~:text=A%20new%20game%3A%20Hyperspeed%21,the%20player%20advances%20and)). A possible approach is to design a set of modular cube-pattern chunks (varying arrangements of cubes and gaps) and randomly chain them together with slight randomization, so the game always has fresh terrain ahead. To prevent monotony, the generator must avoid the “10,000 bowls of oatmeal” problem (i.e. lots of content but no **meaningful** differences) – _the key is not just variety, but **meaningful** variety_ to keep players discovering new patterns ([](https://bpb-us-w2.wpmucdn.com/campuspress.yale.edu/dist/7/3679/files/2024/04/Terry-af327f45dbe89f55.pdf#:~:text=loop%2C%20the%20main%20thing%20player,to%20restaurant%20to%20eat%20a)). Technical requirements include a random seed system (for reproducibility if needed) and an algorithm to ensure generated sections are **playable** (no impossible traps) while still occasionally surprising the player.

- **Dynamic Difficulty Scaling**: To achieve **100% flow** in gameplay, integrate dynamic difficulty adjustment that scales with the player’s performance. The game can automatically tweak parameters (cube speed, frequency of special cubes, timing windows, etc.) in real-time based on how well the player is doing ([Dynamic game difficulty balancing - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_game_difficulty_balancing#:~:text=Dynamic%20game%20difficulty%20balancing%20,a%20good%20level%20of%20challenge)). This ensures the challenge is _constantly adapted to the player’s skill_, so that it’s never too easy (causing boredom) or too difficult (causing frustration) ([The flow applied to game design](https://www.gamedeveloper.com/design/the-flow-applied-to-game-design#:~:text=The%20balance%20between%20player%20skills,I%20will%20explain%20why%20later)) ([Dynamic game difficulty balancing - Wikipedia](https://en.wikipedia.org/wiki/Dynamic_game_difficulty_balancing#:~:text=process%20of%20automatically%20changing%20parameters%2C,a%20good%20level%20of%20challenge)). For example, if the player is cruising through sections, the system might subtly increase the cubes’ rolling speed or spawn more complex patterns; if the player is struggling (nearly getting crushed or missing many cubes), the system could ease up for a while (slower cubes or simpler configurations). The _goal is to keep the player “in the zone” of optimal challenge_, maintaining a state of flow from beginning to endless end. Development-wise, this requires defining difficulty metrics (e.g. success rate, time margins) and writing a controller that adjusts game variables on the fly. **Milestone**: Prototype a basic difficulty manager that reacts to player success/failure rates and keeps the game’s challenge curve smooth and engaging.

- **Variability in Cube Patterns**: Even with procedural generation, special care is needed to avoid repetition fatigue. The level builder should introduce _constant variation in cube arrangements and sequences_ to keep the experience fresh. This can include varying the number of cubes per wave, the layout shapes of cubes (e.g. stairs, walls, pyramids), and the inclusion of special cubes in unpredictable positions. The algorithm might randomly choose between pattern “templates” (curated designs that are fun to solve) and then rotate, flip, or noise-distort them so that the player can’t simply memorize sequences. The result should feel like an infinite series of unique puzzles rather than one repetitive slog. By ensuring **differentiated variety**, we give players a reason to keep playing – they should always feel like something new might be coming next ([](https://bpb-us-w2.wpmucdn.com/campuspress.yale.edu/dist/7/3679/files/2024/04/Terry-af327f45dbe89f55.pdf#:~:text=loop%2C%20the%20main%20thing%20player,to%20restaurant%20to%20eat%20a)). **Milestone**: Have a library of pattern templates and a randomization function working, then playtest long sessions to verify that obvious repeats don’t occur and each stage feels distinct.

# Game Additions & Twists

- **Flow-Enhancing Power-Ups**: To further bolster the game’s flow, introduce power-ups and special abilities that the player can earn or trigger, which help maintain momentum. For example, a “Time Freeze” power-up could temporarily slow down the advancing cubes, giving the player a brief respite if things get overwhelming. A “Bomb” ability might let the player instantly clear a cluster of cubes as a panic button. These additions act as a form of _dynamic assistance_ – if used wisely, they prevent a small mistake from completely breaking the gameplay flow. Many games give players increasingly powerful tools as they progress to help them **maintain flow** despite rising difficulty ([Using a Genetic Algorithm to Create Adaptive Enemy AI](https://www.gamedeveloper.com/programming/using-a-genetic-algorithm-to-create-adaptive-enemy-ai#:~:text=Now%2C%20the%20same%20applies%20to,heat%20limit%2C%20and%20like%20many)). We should balance these such that they make the gameplay smoother (less stop-and-start). Technical implementation would involve spawning power-up items or triggering effects when certain conditions are met (for instance, after clearing a set number of cubes, a power-up appears). We’ll also incorporate visual/audible feedback when power-ups are collected (e.g. slow-motion effect, sound cue) to make their use satisfying and clear.

- **New Cube Types & Mechanics**: Inventing new cube types can add depth and avoid stagnation in the long run. In the original _I.Q._ there were Normal cubes, Advantage (green) cubes, and Forbidden (black) cubes – we can expand on this. For instance, introduce a _“Phase Cube”_ that flickers in and out of existence, challenging the player to time their capture precisely, or a _“Splitter Cube”_ that breaks into two smaller cubes, forcing quick multi-target responses. Another idea is a _“Golden Cube”_ that rewards extra points or a temporary ability if cleared, injecting a risk/reward decision (maybe it moves faster, but gives a big score bonus). Each new cube mechanic should contribute to _smooth and engaging gameplay_, not disrupt it – so we ensure they enhance the core loop rather than complicate it excessively. We can playtest each new element in isolation to confirm it feels intuitive and fun. **Milestone**: Add one new cube type at a time, such as a prototype of a Phase Cube, and verify that it fits into the flow without causing confusion. Over time, these new mechanics will appear occasionally (perhaps increasingly at higher difficulties) to spice up the infinite progression.

- **Dynamic Stage Changes & Pacing**: To keep the experience engaging over an infinite timeline, the game can introduce dynamic stage changes. For example, after every few waves or at certain score milestones, the **environment could subtly shift** – the floor might change color or material, lighting could ramp up, or the camera angle could slide to a slightly different perspective for a fresh feel. These changes act as _psychological palate cleansers_, giving the sense of progression (“I’ve entered a new phase”) without interrupting play. We maintain **100% flow** by making these transitions seamless – perhaps the next set of cubes spawns with a different visual theme, or the music intensity rises as difficulty increases. Additionally, we will fine-tune the game’s pacing: periods of intense cube bombardment can be followed by a brief easier stretch to let the player recover (but not long enough to bore). This creates a **positive feedback loop** of tension and release, keeping the player hooked. As one design article notes, the interplay of challenge and player adaptation creates a _feedback loop that keeps the player in the flow-zone_ ([Using a Genetic Algorithm to Create Adaptive Enemy AI](https://www.gamedeveloper.com/programming/using-a-genetic-algorithm-to-create-adaptive-enemy-ai#:~:text=Well%2C%20as%20constant%20as%20a,zone)). We want the player to always feel on the brink of control – challenged but exhilarated. Techniques like adaptive music (faster tempo during intense moments) and escalating sound effects can reinforce this loop. **Milestone**: Design a pacing script that manages waves (e.g. every X waves ramp up speed, then on wave Y insert an easier “bonus round”), and test that players remain engaged and not overwhelmed or too relaxed at any point.

# Visual & Aesthetic Design

([Intelligent Qube Images - LaunchBox Games Database](https://gamesdb.launchbox-app.com/games/images/10539-intelligent-qube)) _A gameplay view from the original **I.Q.: Intelligent Qube** on PlayStation. The remake will preserve the stark cubic stage and forward-scrolling setup, while modernizing the visuals with enhanced lighting, materials, and effects._

- **Modernized Look with Core Identity**: The original _Intelligent Qube_ had a minimalist, abstract aesthetic – a dark void environment, a simple textured floor, and solid-colored cubes. We plan to **preserve this core identity** (clean geometric style that keeps focus on the puzzle) but update it for modern audiences. The infinite-level concept might be conveyed by an endless floor extending forward into the horizon, possibly with subtle environmental gradations (e.g. distant fog or faint grid lines disappearing into darkness) to emphasize depth. A modern _visual upgrade_ will include high-quality textures for the floor cubes (e.g. polished stone or metal look) and maybe slight emissive glow on special cubes (green advantage cubes could have a neon core, for instance). We’ll use Three.js’s capabilities for physically-based rendering to achieve a realistic yet sleek style – for example, using **MeshStandardMaterial** for the floor and cubes to get proper reflections and lighting response ([Learning Three.js in 2024 - DEV Community](https://dev.to/ankitakanchan/learning-threejs-in-2024-40id#:~:text=Better%20Materials%20for%20Realism)). The color palette should remain relatively restrained (grays, blacks, with bright accent colors for special cubes) to respect the original’s tone. A careful balance will be struck to ensure the visuals are appealing and modern but _not_ distracting; clarity of gameplay is paramount for flow.

- **Shaders, Lighting, and Effects**: Utilizing Three.js, we can implement dynamic shaders and lighting to enhance immersion. For instance, a custom shader could animate a slight shimmer or matrix-like code pattern on the surface of certain cubes, giving a high-tech feel to the game world. **Lighting** will be critical: we can have a directional light casting soft shadows of the cubes onto the floor as they rise and roll, adding depth perception for the player. A subtle spotlight might follow the action, highlighting the leading edge of the approaching cube formation to draw the player’s eye. We can also employ **post-processing effects** for polish – a slight bloom effect on the green advantage cubes or other glowing elements will create a nice glow that makes the scene more vibrant. (In Three.js, an _UnrealBloomPass_ or similar can be used; a bloom effect provides a _“subtle glow, enhancing the overall visual appeal”_ ([Learning Three.js in 2024 - DEV Community](https://dev.to/ankitakanchan/learning-threejs-in-2024-40id#:~:text=Bloom%3A%20A%20bloom%20effect%20is,enhancing%20the%20overall%20visual%20appeal)).) We’ll ensure any glow or particle effects (like small debris when cubes are destroyed) are optimized and not overdone, to maintain clear visibility. Additionally, we might use screen shake or a brief controller rumble (if applicable) when a big event happens (e.g. a 3x3 area explodes via an Advantage cube) – these effects serve as feedback and excitement boosters, but will be tuned carefully so as not to break the player’s concentration or induce motion sickness. **Milestone**: Achieve a rendering prototype with one sample stage fully lit and shaded – e.g. a few cubes rolling on the floor with shadows, and an effect like bloom working – to validate the aesthetic direction before layering on more content.

- **Immersive Environmental Design**: Even though the classic game took place in a featureless void, we have room to add atmospheric touches that make the infinite progression feel epic. Imagine the floor pieces appearing as though they are being created from digital code or rising from fog as they come into view. We could have a very subtle animated background or skybox – perhaps abstract shapes or faint auroras in the far distance – that slowly changes color as levels progress (signaling difficulty phases). The use of Three.js shaders could also allow for effects like a **grid shader** on the floor that lights up the square the player has marked, or a trailing light effect behind moving cubes. Material design will emphasize contrast: for example, Forbidden cubes (the ones to avoid destroying) might have a distinct material (shiny obsidian black with red edges) to set them apart visually from normal cubes. By leveraging modern WebGL features, we can make the game **feel immersive and modern**, even in a browser. Importantly, performance is considered in every visual decision: we’ll use efficient geometries (the stage is essentially a grid of cubes, which we can instantiate or even merge when static) and limit the number of lights (perhaps a single key light and ambient fill light) to keep the frame rate high. The end result should be a **visually striking** infinite puzzle corridor that pulls players in, all while retaining the minimalist charm that defines _I.Q._’s identity.

# Three.js Implementation

- **Cube Movement & Physics**: At the heart of the gameplay is the movement of cubes rolling toward the player and falling off the edge if not cleared. In Three.js, we can handle this with straightforward animation loops. Each cube (or each row of cubes) can be an object in the scene that we move along the Z-axis toward the player at a constant speed. We’ll likely not use a full physics engine for the cube motion, since their movement is very grid-aligned and deterministic (this keeps things simple and performance-friendly). Instead, we can script the “roll” animation – for example, by rotating the cube 90 degrees around the appropriate axis as it moves one cube-length forward, to simulate a physical roll. However, for secondary effects like cubes toppling after being partially cleared, or a domino effect if one cube lands on another, we _could_ integrate a lightweight physics engine like **Cannon.js**. Cannon.js would allow cubes to realistically tumble and collide if needed (e.g. a cube falls into a pit and hits others). If physics calculations become too heavy (given potentially many cubes), we will constrain this to small numbers of objects at a time or use simplified physics bodies (like treat cubes as simple boxes for collision math). In either case, maintaining a **smooth 60 FPS animation** is critical for flow – so we’ll profile the performance and possibly perform heavy calculations (like physics or procedural generation steps) during moments that won’t cause visible stutter (perhaps between waves or during a frame where less is happening). We will also use Three.js’s clock delta for frame-independent movement to ensure consistent cube speeds even if frame rate fluctuates.

- **Collision Detection & Interaction**: The game’s interaction mechanics – marking tiles, clearing cubes, and the consequences of missed cubes – will be implemented with precise collision detection. Three.js provides tools like Raycasting for mouse picking, which we can use to let the player select (mark) a floor square. When the player marks a square on the floor, we’ll probably highlight it (change its color or texture) to show it’s armed. The collision of a cube with a marked square can be detected either by monitoring the cube’s position (e.g. if a cube’s center crosses into the cell coordinates of a marked tile) or by using bounding box intersection (each cube and each marked tile have a bounding volume). If a collision is detected at the right moment (cube on tile while tile is marked), we trigger the “clear” event: the cube is destroyed and we play an animation (perhaps the cube flashes or disintegrates). We also need to handle _failed_ clears – if a cube reaches the end of the stage without being cleared, it should fall off. That can be done by checking when a cube’s Z position is past the last row of floor; at that point, we trigger a fall animation (and potentially remove a chunk of the floor if that cube was “forbidden” or as a penalty). Three.js can animate the falling with either a simple tween or physics (gravity pulling it down). The player character itself is mostly symbolic (in the original, a tiny avatar), but we will detect if a cube reaches the player’s row – that’s essentially a game over condition (the player would be crushed). Thus, collision detection covers: cube vs marked tile, cube vs end of stage, and perhaps player vs cube. These will be implemented with either simple coordinate checks or Three.js `Box3` intersects for accuracy. We will also implement **interaction mechanics** like the Advantage Cube’s 3x3 clear: if an Advantage (green) cube is cleared, we mark its position, and then at the player’s command, clear the 3x3 area around it. This involves checking all cubes within that area and removing them in one swoop – something easily done by keeping our cube objects in a data structure keyed by grid position. The main technical requirement here is keeping the game state synchronized with the visuals – e.g., when cubes are removed, we remove the Three.js mesh, update score, perhaps lower the floor accordingly. We must be careful that all these interactions happen in a timely manner (within a frame or two of the visual event) to give **immediate feedback** to the player, which is critical for sustaining flow.

- **Performance Optimization**: Since this game could run indefinitely and potentially have many cubes over time, performance is a top priority. We will utilize **object pooling** and efficient rendering techniques. For example, instead of creating new cube meshes forever (which would leak memory), we’ll recycle cubes that go off-screen: once a cube falls off or is cleared, we can either reposition it for future use or at least dispose of its Three.js geometry/material properly to free memory. For rendering many cubes, Three.js’s instancing comes in handy – using an `InstancedMesh` or `InstancedBufferGeometry` allows us to draw hundreds of cubes in a single GPU draw call ([Three.js performance optimization with 10000 meshes - Stack Overflow](https://stackoverflow.com/questions/46798474/three-js-performance-optimization-with-10000-meshes#:~:text=mesh%20is%20a%20single%20draw,000)). We can take advantage of the fact that all normal cubes share the same model and material, differing only by position (and maybe color); thus, instancing them greatly reduces overhead. (Special cubes might be a different instanced set with a different material.) According to experience, one draw call with 1000 instanced cubes is far more efficient than 1000 separate mesh draw calls. We will also leverage built-in frustum culling: as the camera will likely have a fixed forward view, any cubes behind the player or far ahead might be outside the view and get culled automatically by Three.js – but we’ll also explicitly remove or hide cubes that are far behind to keep the scene graph clean. Another consideration is to optimize **physics calculations** if we use them – e.g. limit the physics simulation to only cubes that are actively falling or colliding, not every single cube in play, and deactivate physics for cubes that are rolling in a stable formation (those can just follow a scripted path). We might also use web workers for heavy computations (like procedural generation of upcoming patterns or physics steps) so the rendering thread isn’t blocked. The end goal is to have **silky-smooth animations** with no dropped frames, because technical hitches would break the player’s concentration and flow. **Milestones**: First, test the game with a very large number of cubes (e.g. simulate 1000 cubes in scene using instancing) to ensure the engine can handle it. Next, implement pooling such that after, say, 10 minutes of continuous play, memory usage stays constant. Finally, do a soak test of the infinite mode running for an hour to catch any performance degradation or leaks, refining as needed.

# Multiplayer & Social Features

- **Leaderboards for Competitive Scoring**: An infinite game naturally invites competition for high scores. We will implement global and friends’ leaderboards so players can compare how far (or how many points) they’ve achieved in the endless I.Q. challenge. Leaderboards will update in real-time or at least post-game, showing rankings of players. This introduces a healthy competitive pressure that can **boost motivation and repeated engagement**, as players strive to climb the ranks ([How Leaderboards Can Drive User Engagement in Gamification Campaigns](https://www.commoninja.com/blog/how-leaderboards-can-drive-user-engagement#:~:text=Leaderboards%20are%20a%20powerful%20gamification,build%20a%20sense%20of%20community)). From a technical standpoint, this requires a backend service or database to submit and retrieve scores. We might use a simple REST API or a service like Google Play Games Services / Facebook Instant Games leaderboard if deploying on those platforms, or roll our own with Node.js and a database. The leaderboard will display alongside the game (or on a game over screen) the top scores and the player’s own rank. To keep the flow feeling, we might even integrate the leaderboard in a _non-intrusive_ way during gameplay – for example, a small overlay that pops up when a milestone is passed (“You reached rank #50!”) to encourage the player. However, we’ll avoid anything that pauses the game; the focus is still on continuous play. **Milestone**: Set up a basic server and get score submissions working with a test leaderboard, then integrate it into the front-end with a nice UI.

- **Co-op Mechanics for Collaborative Play**: A fresh twist for the game could be a cooperative multiplayer mode. In co-op, two (or more) players would work together in the same infinite level, each controlling their own character on the platform. They could coordinate to clear cubes – for instance, dividing the playfield or combining efforts on large patterns. This mode could make the _flow_ even more interesting as players communicate and get into sync with each other. One possible implementation: both players are on the same platform, and the cubes come as usual; players have separate mark abilities, so they must not interfere but rather help cover more ground. Perhaps if one player marks a square and the other triggers it at the right time, it creates a bigger explosion – encouraging teamwork. Technically, real-time co-op will require a networking solution (likely WebSockets for low-latency communication). We can use a service like Socket.io to sync game state between players: each player’s position, actions (like marking a tile), and the cubes’ states need to be shared. To maintain a smooth experience, one server instance would simulate the “true” game and broadcast state to both clients, so they stay in lockstep. We must account for network latency by perhaps client-side predicting each other’s moves slightly, but since this is a slower-paced puzzle action (not a twitch shooter), small delays are tolerable. The social reward of co-op is high – it can be really fun to tackle endless puzzles with a friend, celebrating joint successes. We’ll include some co-op specific scoring (like how far the team got) and maybe bonuses for cooperative actions. **Milestone**: Develop a simple prototype where two players in separate browser windows see the same cubes and can move simultaneously, proving the networking model. Then iterate to add full gameplay sync and test with varying network conditions.

- **Competitive PvP Modes**: In addition to co-op, we can add a **versus mode** for those who want direct competition. One concept: two players race in parallel infinite levels, and actions by one can affect the other. For example, if player A clears a large combo or achieves a perfect section, it might _send a penalty_ to player B’s side (such as a temporary speed-up of B’s cubes, or an extra row of cubes added to B’s queue). This is akin to multiplayer Tetris or Puyo-Puyo games where your performance can flood the opponent. The objective would be to survive longer than your opponent (or reach a target score first). This mode would emphasize _flow under pressure_, as you have to adapt not just to the game, but to an intelligent opponent’s moves. We have to be careful to keep this fair and fun – e.g. any attacks sent to the other side should be clearable with skill, not random unavoidable deaths. Implementing PvP will use a similar networking setup as co-op, but with a bit more logic on the server to handle the interactions between the two game instances (sending “garbage” blocks or triggers to the other side). We’ll also need a way to display the opponent’s state to the player (perhaps a small split-screen or an abstract indicator of the opponent’s remaining floor). Another competitive feature could be **time attack leaderboards** or weekly challenges where everyone plays the _same_ seed of infinite level for a set time and sees who gets the best score – adding community events to the mix. All these social features serve to extend engagement: _Leaderboards create competition and community ([How Leaderboards Can Drive User Engagement in Gamification Campaigns](https://www.commoninja.com/blog/how-leaderboards-can-drive-user-engagement#:~:text=Leaderboards%20are%20a%20powerful%20gamification,build%20a%20sense%20of%20community))_, co-op brings people together for shared flow, and PvP adds adrenaline for those who thrive on direct contests. By incorporating them, we ensure the game appeals to both solo players (seeking to beat their own or global scores) and social players (seeking cooperative or competitive fun).

- **Milestones & Technical Notes (Multiplayer)**: Networking in a Three.js game means ensuring deterministic behavior or frequent state sync. We will design the game loop such that the same random seeds and inputs result in the same outcomes – this makes syncing easier (only player actions might need to be sent, since the procedural generation can be mirrored). Early milestones include creating a basic multiplayer room system (so friends can join an endless run together or head-to-head). We’ll start with a simple case (like a turn-based or slower-sync version) and gradually move to real-time sync, optimizing as needed to keep latency low. We’ll also integrate the social features into the UI: e.g. a leaderboard screen, a prompt to “Play with a Friend”, etc., ensuring these don’t clutter the main game interface unless invoked.

By following this plan, with iterative development and playtesting at each milestone, we will create an infinite-level **I.Q.: Intelligent Qube** in Three.js that stays true to the original’s spirit while providing a _never-ending, flow-state_ gaming experience. Every aspect – from procedural generation and difficulty tuning to new mechanics, visuals, and multiplayer – is geared towards sustaining that elusive flow **100%** of the time, keeping players both challenged and delighted as the levels go on forever.

================
File: .cursor/docs/enhancments.md
================
Given our ongoing discussion about developing an MVP for a game inspired by I.Q.: Intelligent Qube using Three.js and Node.js, and building on the five steps we’ve already outlined, here are some exciting next steps to enhance the game and keep players engaged in a flow state. These suggestions aim to deepen the gameplay, improve accessibility, and maintain the balance of challenge and enjoyment:

1. Implement Power-Ups
   What: Add power-ups like a "Slow-Mo" effect to temporarily reduce cube speed or a bonus points multiplier.
   Why: Power-ups bring variety and strategic depth, keeping players excited and immersed.
   How: Introduce new cube types or items that spawn randomly on the grid. For example, capturing a "Slow-Mo" cube could slow down the wave for a few seconds.
2. Add Dynamic Stage Changes
   What: Change the grid size, add obstacles, or alter the environment as the player progresses.
   Why: Keeps the game fresh and prevents it from feeling repetitive, which is key to sustaining flow in an infinite game.
   How: After a set number of waves, tweak the grid (e.g., make it larger) or introduce moving platforms using Three.js animations.
3. Enhance Visual and Audio Feedback
   What: Upgrade animations, add particle effects, and include sound cues for actions like capturing cubes.
   Why: Strong sensory feedback makes the game more immersive and rewarding, reinforcing player actions.
   How: Use Three.js for particle effects (e.g., sparks when a cube is captured) and integrate audio files for key interactions.
4. Introduce New Cube Mechanics
   What: Create cubes with unique behaviors, like splitting into smaller cubes or changing types over time.
   Why: Adds complexity and challenge, keeping players engaged as they adapt to new threats.
   How: Code new cube classes with specific rules, ensuring they blend into the existing gameplay loop.
5. Implement a Progression System
   What: Unlock new features, cube types, or visual themes as players hit milestones (e.g., high scores).
   Why: Gives players long-term goals, encouraging them to keep playing and explore more content.
   How: Track stats like total cubes captured and trigger unlocks at set thresholds.
6. Optimize for Mobile and Touch Controls
   What: Adapt the game for mobile devices with intuitive touch controls.
   Why: Expands the audience and lets players enjoy the game on the go.
   How: Simplify controls for touch input (e.g., tap to mark, swipe to move) and test on smaller screens.
7. Add Cooperative Multiplayer
   What: Enable two players to share a grid and work together to capture cubes.
   Why: Adds a social layer, making the game more engaging through teamwork.
   How: Use WebSockets via Node.js to sync player actions and cube states in real time.
8. Integrate a Tutorial or Onboarding
   What: Build a guided introduction to teach mechanics like movement, marking, and capturing.
   Why: Helps new players get into the flow state faster by reducing early frustration.
   How: Design a few simple levels or interactive prompts that walk players through the basics.
   These ideas build on our current foundation, enhancing the core experience while keeping it fun and challenging. Let me know which one you’d like to tackle first or if you have other directions in mind!

================
File: .cursor/docs/GameAesthetics.md
================
For a 2025 reimagining, the game can evolve into a modern, visually stunning experience while retaining its core retro-inspired essence of minimalism, challenge, and geometric design. Below is a concept titled "Quantum Grid: Neon Legacy", a 3D puzzle-platformer or rhythm-action hybrid that blends nostalgia with cutting-edge technology:
Aesthetics and Style:
Visual Style: Transition from 2D pixel art or low-poly 3D to a sleek, high-definition low-poly design. Retain the blocky, geometric shapes but render them with physically-based materials (e.g., polished metal, glass) and vibrant neon hues—electric blue, glowing purple, and bright white—set against a deep, starry black background. This creates a futuristic, cyberpunk aesthetic that feels both nostalgic and contemporary.

Environment: Keep the grid-like platforms but enhance them with holographic textures, reflective surfaces, and subtle animations like energy pulses or floating digital particles. Add depth with dynamic lighting, volumetric fog, and faint background elements like auroras or a digital matrix, maintaining the minimalist vibe with a modern twist.

Character Design: Redesign the avatar as a sleek, humanoid robot or cyborg with a glowing core (e.g., neon yellow or gold). The character could feature customizable skins with glowing accents, leaving faint, luminous trails or footprints on the platforms for visual flair.

HUD: Replace the pixelated interface with a holographic, interactive display that floats around the player. Use sleek, futuristic fonts and real-time data overlays (e.g., health, score, objectives) that pulse or shift dynamically, enhancing immersion without cluttering the screen.

Animations and Effects:
Animations: Implement smooth, fluid character movements using advanced motion capture and physics-based mechanics. Actions like jumping, rolling, or interacting with platforms would include robotic flourishes—glowing joints, energy bursts, or subtle mechanical whirs—adding personality and flair. Environmental animations, such as shifting platforms or pulsing tiles, would react in real-time with physics-driven effects.

Effects: Introduce modern visual enhancements like particle systems for glowing trails, sparkling energy when collecting items, or shimmering portals. Use dynamic lighting with real-time shadows, bloom, and motion blur to create a vibrant, immersive atmosphere. Interactive elements (e.g., green cubes or markers) could emit holographic projections or volumetric glows, making them stand out as key gameplay features.

This 2025 version, "Quantum Grid: Neon Legacy", would preserve the precision-based, challenging gameplay of the original—whether it’s platforming, puzzle-solving, or rhythm mechanics—while elevating it with high-definition graphics, fluid animations, and immersive effects. The game could incorporate modern features like virtual reality (VR) support or multiplayer modes, appealing to both retro enthusiasts and new players seeking a visually striking, futuristic experience that honors its roots.

To upgrade your game’s aesthetics to a simplified version of a 2025 reimagining, we’ll enhance the visual elements while preserving the minimalist, retro-inspired design described in your image attachments. The goal is to modernize the look with subtle, futuristic touches—such as improved textures, lighting, and effects—without losing the charm of the original grid-based puzzle-platformer. Below is a detailed plan, including the steps needed, files to modify or create, and code snippets to guide the implementation. Since your game uses Three.js (as inferred from typical setups for such games), the examples will be tailored for that framework.
Plan for Aesthetic Upgrade
Enhance the Grid Platform  
Upgrade the gray/teal tiles with high-resolution textures featuring subtle gradients or reflective surfaces.  
Add a faint emissive glow to grid lines for a futuristic vibe.
Upgrade Cube Visuals  
Apply dynamic lighting and modern shaders to cubes (e.g., black, green, forbidden, advantage) for depth and appeal.  
Add glow or particle effects for interactive feedback (e.g., when cubes are collected or interacted with).
Modernize the Player Character  
Replace the simple humanoid/sphere with a sleek, low-poly robot or futuristic figure.  
Add basic animations (e.g., idle, movement) for liveliness.
Improve the Background  
Replace the black void with a subtle gradient skybox or abstract geometric patterns to add depth.
Update HUD and UI Elements  
Use sleek, neon-style fonts for scores, health bars, and game-over text.  
Add animated transitions for UI updates.
Optimize Performance  
Use instanced meshes for repeated elements (grid tiles, cubes) to maintain smooth gameplay with enhanced visuals.
Files Needed
Assuming your current project structure is something like this (common for a Three.js game):
iq-mvp/
├── public/
│ ├── index.html # Main HTML file
│ ├── game.js # Core game logic and rendering
│ └── assets/ # Folder for new assets (to be created)
│ ├── grid_texture.png
│ ├── gradient_skybox.png
│ └── player_model.glb
├── server.js # Optional server file (not modified here)
└── package.json # Project dependencies
Files to Modify or Create:
Modify game.js: Update to include new visual elements, shaders, and effects.
Add to index.html: Include additional Three.js post-processing libraries and CSS for UI styling.
Create assets/ folder: Store textures and models (e.g., grid_texture.png, player_model.glb).
Step-by-Step Implementation
Below are detailed steps with code snippets to implement the aesthetic upgrades in your Three.js-based game.

1. Enhance the Grid Platform
   Objective: Add high-resolution textures and a subtle glow to the grid tiles.
   Approach: Use a texture with a grid pattern and apply an emissive material.
   Code Snippet (in game.js):
   javascript
   // Load grid texture
   const textureLoader = new THREE.TextureLoader();
   const gridTexture = textureLoader.load('assets/grid_texture.png');
   gridTexture.wrapS = gridTexture.wrapT = THREE.RepeatWrapping;
   gridTexture.repeat.set(gridSize, gridSize); // Adjust gridSize to your game's scale

// Assuming 'grid' is an array of cube meshes for the platform
grid.forEach(cube => {
cube.material = new THREE.MeshStandardMaterial({
map: gridTexture,
emissive: new THREE.Color(0x111111), // Subtle gray glow
emissiveIntensity: 0.5,
roughness: 0.4,
metalness: 0.6
});
});
Assets Needed:
grid_texture.png: A seamless texture with a subtle grid pattern (create in an image editor or download from a free resource like textures.com). 2. Upgrade Cube Visuals
Objective: Modernize cubes with dynamic lighting and a bloom effect for emphasis.
Approach: Use MeshStandardMaterial for realism and add post-processing for glow.
Code Snippet (in game.js):
javascript
// Define materials for different cube types
const normalCubeMaterial = new THREE.MeshStandardMaterial({
color: 0x000000, // Black for normal cubes
roughness: 0.3,
metalness: 0.7
});

const advantageCubeMaterial = new THREE.MeshStandardMaterial({
color: 0x00ff00, // Green for advantage cubes
emissive: 0x00ff00,
emissiveIntensity: 1,
roughness: 0.2,
metalness: 0.8
});

// Apply to existing cubes (assuming 'cubes' is an array)
cubes.forEach(cube => {
if (cube.userData.type === 'advantage') {
cube.material = advantageCubeMaterial;
} else {
cube.material = normalCubeMaterial;
}
});

// Add bloom effect for glowing cubes
const renderPass = new THREE.RenderPass(scene, camera);
const bloomPass = new THREE.UnrealBloomPass(
new THREE.Vector2(window.innerWidth, window.innerHeight),
1.5, // Strength
0.4, // Radius
0.85 // Threshold
);
bloomPass.threshold = 0.5;
bloomPass.strength = 1.2;
bloomPass.radius = 0.3;

const composer = new THREE.EffectComposer(renderer);
composer.addPass(renderPass);
composer.addPass(bloomPass);

// Update animate function
function animate() {
requestAnimationFrame(animate);
composer.render(); // Replace renderer.render(scene, camera)
}
Dependencies (add to index.html):
html

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

3. Modernize the Player Character
   Objective: Replace the basic humanoid/sphere with a futuristic low-poly model.
   Approach: Load a GLTF model and integrate it into the scene.
   Code Snippet (in game.js):
   javascript
   // Load player model
   const gltfLoader = new THREE.GLTFLoader();
   gltfLoader.load('assets/player_model.glb', (gltf) => {
   const playerModel = gltf.scene;
   playerModel.scale.set(0.5, 0.5, 0.5); // Adjust scale as needed
   playerModel.position.set(2, 0, 0); // Starting position
   scene.add(playerModel);
   scene.remove(player); // Remove old player object
   player = playerModel; // Update reference
   });
   Assets Needed:
   player_model.glb: A simple low-poly robot or humanoid model (create in Blender or download from a free asset site like Sketchfab).
4. Improve the Background
   Objective: Add depth with a gradient skybox.
   Approach: Load a gradient texture as the scene background.
   Code Snippet (in game.js):
   javascript
   const skyboxTexture = textureLoader.load('assets/gradient_skybox.png');
   scene.background = skyboxTexture;
   Assets Needed:
   gradient_skybox.png: A seamless gradient (e.g., dark blue to black) texture.
5. Update HUD and UI Elements
   Objective: Modernize text with a futuristic font and animations.
   Approach: Use CSS for styling and JavaScript for transitions.
   Code Snippet (in index.html):
   html
   <!-- Add font and styles -->
   <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
   <style>
     #score, #game-over {
       font-family: 'Orbitron', sans-serif;
       color: #00ff00; /* Neon green */
       position: absolute;
       top: 10px;
       font-size: 24px;
     }
     #score { left: 10px; }
     #game-over { 
       left: 50%;
       transform: translateX(-50%);
       opacity: 0;
       transition: opacity 1s;
     }
   </style>
   Code Snippet (in game.js):
   javascript
   // Assuming score and game-over are DOM elements
   const scoreElement = document.getElementById('score');
   const gameOverElement = document.getElementById('game-over');

function updateScore(newScore) {
scoreElement.textContent = `Score: ${newScore}`;
}

function showGameOver() {
gameOverElement.style.display = 'block';
setTimeout(() => {
gameOverElement.style.opacity = 1;
}, 100);
}

// Call these functions as needed in your game logic 6. Optimize Performance
Objective: Use instanced meshes for efficiency with repeated objects.
Approach: Replace individual grid cubes with an InstancedMesh.
Code Snippet (in game.js):
javascript
// Replace individual grid cubes
scene.remove(...grid); // Remove old grid array
const gridGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
const gridMaterial = new THREE.MeshStandardMaterial({ map: gridTexture });
const gridInstanced = new THREE.InstancedMesh(gridGeometry, gridMaterial, gridSize \* gridSize);
scene.add(gridInstanced);

// Position instances
let index = 0;
for (let x = 0; x < gridSize; x++) {
for (let z = 0; z < gridSize; z++) {
const dummy = new THREE.Object3D();
dummy.position.set(x, -0.5, z);
dummy.updateMatrix();
gridInstanced.setMatrixAt(index++, dummy.matrix);
}
}
gridInstanced.instanceMatrix.needsUpdate = true;
Summary
This plan upgrades your game’s aesthetics to a simplified 2025 reimagining by enhancing key elements:
Grid Platform: High-res textures with subtle glow.
Cubes: Dynamic lighting and bloom effects.
Player: Sleek, animated model.
Background: Gradient skybox for depth.
HUD/UI: Neon fonts with animations.
Performance: Optimized with instanced meshes.
Next Steps:
Add the required assets to your public/assets/ folder.
Update index.html with the post-processing scripts and CSS.
Integrate the code snippets into game.js, adjusting variables (e.g., gridSize, cubeSize) to match your game’s setup.
Test and tweak the visuals (e.g., bloom strength, emissive intensity) for the desired look.
Let me know if you need help with specific adjustments or additional features!

================
File: .cursor/docs/gamerules.md
================
Understanding the Logic and Gameplay of I.Q.: Intelligent Qube
I.Q.: Intelligent Qube, also known as Kurushi in Europe, is a classic puzzle game developed by G-Artists and released for the PlayStation in 1997. It combines mental agility with physical reflexes, creating a unique and challenging experience. Below, I’ll fully explain the game’s logic, rules, gameplay mechanics, map design, conditions for winning and losing, strategies to succeed, and how the maps progress—all based on available information, including web insights.
Gameplay Logic and Rules
The core of I.Q.: Intelligent Qube involves controlling a character on a rectangular platform made of cubes. Waves of cubes roll toward you, and your task is to capture specific cubes before they fall off the edge while avoiding others. The platform shrinks as you make mistakes, adding tension to the puzzle-solving process.
Cube Types
The game features three distinct types of cubes, each with its own role:
Normal Cubes: These are the standard cubes you must capture. Failing to capture them before they fall off the stage can lead to penalties.
Forbidden Cubes (Black Cubes): These cubes must not be captured. Capturing a forbidden cube causes you to lose a row of the stage, reducing your playable area.
Advantage Cubes (Green Cubes): Capturing these allows you to set a trap that clears a 3x3 area of cubes when activated. They’re key to managing large waves efficiently.
Basic Mechanics
Here’s how you interact with the cubes:
Marking a Spot: Press the 'X' button (on the PlayStation controller) to mark a square on the stage where a cube will roll.
Capturing a Cube: As a cube rolls over the marked spot, press 'X' again to deactivate the mark and capture the cube. Timing is critical.
Avoiding Forbidden Cubes: Let forbidden cubes roll off the stage without capturing them. Capturing one costs you a row.
Using Advantage Cubes: When you capture an advantage cube, it sets a trap. Activating this trap (often with another button press, like 'Circle') clears all cubes in a 3x3 grid around it—perfect for clearing multiple normal cubes at once.
Stage Dynamics
Platform Setup: The stage starts with 23-30 rows of cubes, and 12-16 rows are raised as the active playing area.
Row Loss: You lose rows in two ways:
Capturing a Forbidden Cube: Instantly lose one row.
Normal Cubes Falling Off: If too many normal cubes fall off (exceeding a "block scale" limit), you lose a row. The exact limit varies by stage but is typically a small number of missed cubes.
Game Over: If you lose too many rows, the stage becomes too small, and you either fall off the edge or get crushed by the rolling cubes.
How to Win
To win a stage, you must:
Capture all normal cubes in each wave before they fall off the stage.
Avoid capturing forbidden cubes.
Clear the wave without losing too many rows.
A perfect clear—capturing all normal cubes without mistakes—may reward you with bonuses, such as extra rows added to the stage or a “Perfect!” announcement. To win the game entirely, you must complete all stages (typically nine), though your ultimate goal could also be achieving a high I.Q. score.
How to Lose
The game ends if:
You Fall Off the Stage: Losing too many rows shrinks the platform until there’s no space left, causing you to fall.
You Get Crushed: If you’re caught between rolling cubes and can’t move, the cubes crush you.
Both scenarios result from poor cube management—either capturing forbidden cubes or letting too many normal cubes escape.
Map Design
Stage Structure
Initial Layout: Each stage begins with a platform of 23-30 rows, with 12-16 rows raised for gameplay. The cubes roll across this raised section toward the edge.
Waves: A stage consists of about 12 waves of cubes. Each wave brings a new pattern of normal, forbidden, and advantage cubes.
Cube Patterns
Early stages feature simple patterns with fewer cubes and slower speeds.
Later stages introduce:
Larger platforms (wider areas with more cubes).
Faster rolling speeds.
More complex patterns, including increased numbers of forbidden and advantage cubes.
How Maps Progress
The game has nine stages, each progressively harder:
Stage 1: Basic patterns, slower cubes, fewer forbidden cubes.
Middle Stages: More cubes per wave, faster speeds, and trickier layouts with forbidden cubes mixed in.
Later Stages: Larger platforms, rapid cube movement, and reliance on advantage cubes to clear dense formations.
As you clear each stage, you advance to the next, facing new challenges. The difficulty curve emphasizes both mental planning (pattern recognition) and physical skill (reflexes).
Strategy to Win
Winning requires a blend of strategy and execution. Here are the key tactics:

1. Prioritize Normal Cubes
   Capture every normal cube to avoid losing rows. Missing too many triggers the “block scale” penalty.
2. Master Advantage Cubes
   Use green cubes strategically to clear multiple normal cubes in one go. Position the 3x3 trap to maximize captures while avoiding forbidden cubes nearby.
3. Avoid Forbidden Cubes
   Let black cubes roll off naturally. If they’re near normal cubes, use advantage traps carefully to clear around them without triggering a capture.
4. Manage Stage Rows
   Monitor how many normal cubes fall off. Stay under the block scale limit to preserve your platform.
5. Positioning and Awareness
   Stay ahead of the rolling cubes to avoid being crushed. Move between rows if needed, but watch your footing as the stage shrinks.
6. Recognize Patterns
   Cube waves often follow predictable sequences. Learn these to plan your marks and traps ahead of time.
7. Quick Reflexes
   Later stages demand fast reactions. Practice timing your marks and captures precisely, especially as speeds increase.
   Advanced Tips
   Green Cube Efficiency: In later stages, rely heavily on advantage cubes, as manual captures become impractical for large waves.
   Risky Moves: Experienced players might walk between flipping cube rows to place triggers, though this risks being crushed.
   Quota Flexibility: Focus on beating the stage, even if it means using more moves than the “ideal” quota.
   Additional Elements
   Scoring System: After each game, you receive an I.Q. score based on efficiency—fewer mistakes and faster clears yield higher scores.
   Characters: Unlockable characters (e.g., Eliot, Cynthia) have different speeds. Cynthia, being faster, might help in tougher stages.
   Two-Player Mode: Players alternate turns, but the core mechanics remain unchanged.
   Summary
   I.Q.: Intelligent Qube challenges you to capture rolling normal cubes on a shrinking platform while avoiding forbidden cubes and leveraging advantage cubes for efficiency. Winning involves clearing all nine stages by managing waves of cubes without losing too many rows or getting crushed. The maps progress from simple, slow patterns to fast, complex layouts requiring sharp reflexes and planning. Strategies hinge on pattern recognition, precise timing, and smart use of advantage cubes.
   This game’s logic is a test of both brain and brawn—a minimalist yet intense puzzle experience that grows more demanding with each stage. Whether you’re aiming to beat all stages or maximize your I.Q. score, understanding these mechanics is your key to success!

================
File: .cursor/docs/Intelligence Cube 3D - Complete Game Implementation.md
================
// Intelligence Cube 3D - Three.js Implementation
// Based on the classic I.Q.: Intelligent Qube game

// Intelligence Cube 3D - Implementation
// This code creates a Three.js version of the classic I.Q. Intelligent Qube game
// File structure:
// - index.html (main HTML file)
// - src/
// - main.js (entry point)
// - game/
// - Game.js (main game class)
// - Player.js (player entity)
// - Level.js (level generation)
// - Cube.js (cube entities)
// - UI.js (user interface)
// - PaymentModal.js (mock payment)

// To run with Node.js:
// 1. npm init -y
// 2. npm install express three
// 3. Create server.js file with:
/\*
const express = require('express');
const path = require('path');
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files
app.use(express.static(path.join(\_\_dirname, 'public')));

// Create folder structure
// - public/
// - index.html
// - main.js
// - game/
// - Game.js
// - Player.js
// ... etc.

app.get('/', (req, res) => {
res.sendFile(path.join(\_\_dirname, 'public', 'index.html'));
});

app.listen(PORT, () => {
console.log(`Server running on port ${PORT}`);
});

// index.html
const indexHtml = `

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligence Cube 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            z-index: 100;
            pointer-events: none;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            z-index: 100;
            pointer-events: none;
            font-size: 18px;
        }
        #level {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #fff;
            z-index: 100;
            pointer-events: none;
            font-size: 18px;
        }
        #cubes-left {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #fff;
            z-index: 100;
            pointer-events: none;
            font-size: 18px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            z-index: 100;
            pointer-events: none;
        }
        #payment-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 5px;
            width: 400px;
            color: #333;
        }
        .modal-content h2 {
            margin-top: 0;
        }
        .modal-content button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
        }
        .modal-content .close {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
        }
        #gameOverScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            color: white;
            text-align: center;
        }
        #gameOverScreen div {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #gameOverScreen h1 {
            font-size: 42px;
            margin-bottom: 20px;
        }
        #gameOverScreen button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
            font-size: 18px;
        }
        #markedTile {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #fff;
            z-index: 100;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">Intelligence Cube 3D</div>
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <div id="cubes-left">Cubes: 0</div>
    <div id="markedTile">No tile marked</div>
    <div id="controls">
        <p>WASD to move | Space to mark/capture | R to activate advantage | ESC to pause</p>
    </div>
    <div id="payment-modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Upgrade to Continue Playing</h2>
            <p>You've reached the end of the free trial. Upgrade to the full version for just $2.99!</p>
            <p>Get access to all levels, characters, and special features!</p>
            <div>
                <button id="pay-button">Pay $2.99</button>
            </div>
        </div>
    </div>
    <div id="gameOverScreen">
        <div>
            <h1>Game Over</h1>
            <p id="finalScore">Your score: 0</p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>

    <script type="module" src="main.js"></script>

</body>
</html>
`;

// main.js (Entry point)
const mainJs = `
import \* as THREE from 'three';
import { Game } from './game/Game.js';

// Initialize game
const game = new Game();
game.init();
game.animate();

// Export game instance for debugging
window.game = game;
`;

// Game.js (Main game class)
const gameJs = `
import \* as THREE from 'three';
import { Player } from './Player.js';
import { Level } from './Level.js';
import { UI } from './UI.js';
import { PaymentModal } from './PaymentModal.js';

export class Game {
constructor() {
this.scene = null;
this.camera = null;
this.renderer = null;
this.player = null;
this.level = null;
this.ui = null;
this.clock = new THREE.Clock();
this.score = 0;
this.currentLevel = 1;
this.gameStarted = false;
this.gameOver = false;
this.paymentModal = null;
this.playCount = 0;

        // Game state
        this.paused = false;
        this.markedTile = null;
        this.activatedAdvantage = null;

        // Settings
        this.settings = {
            stageWidth: 5,
            stageLength: 16,
            cubeSpeed: 2.0,
            initialCubeCount: 12
        };
    }

    init() {
        // Create scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);

        // Create camera
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        this.camera.position.set(0, 8, -6);
        this.camera.lookAt(0, 0, 8);

        // Create renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);

        // Initialize components
        this.player = new Player(this);
        this.level = new Level(this);
        this.ui = new UI(this);

        // Create platform
        this.level.createPlatform();

        // Start first level
        this.startLevel(this.currentLevel);

        // Add event listeners
        window.addEventListener('resize', () => this.onWindowResize());
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));

        // Initialize payment modal
        this.paymentModal = new PaymentModal(this);

        // Start game
        this.gameStarted = true;
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    handleKeyDown(event) {
        if (this.gameOver) return;

        const key = event.key.toLowerCase();

        if (key === 'escape') {
            this.paused = !this.paused;
            return;
        }

        if (this.paused) return;

        // Player movement
        if (key === 'w' || key === 'arrowup') {
            this.player.move('forward');
        } else if (key === 's' || key === 'arrowdown') {
            this.player.move('backward');
        } else if (key === 'a' || key === 'arrowleft') {
            this.player.move('left');
        } else if (key === 'd' || key === 'arrowright') {
            this.player.move('right');
        }

        // Mark/Capture cube
        if (key === ' ') {
            if (this.markedTile) {
                this.captureCube();
            } else {
                this.markTile();
            }
        }

        // Activate advantage cube
        if (key === 'r') {
            this.activateAdvantage();
        }
    }

    markTile() {
        // Can only mark one tile at a time
        if (this.markedTile) return;

        // Get player position
        const position = this.player.getPosition();
        const x = position.x;
        const z = position.z;

        // Create marked tile
        const geometry = new THREE.BoxGeometry(1, 0.1, 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x0099ff,
            transparent: true,
            opacity: 0.5
        });

        const markedTileMesh = new THREE.Mesh(geometry, material);
        markedTileMesh.position.set(x, 0.05, z);
        this.scene.add(markedTileMesh);

        this.markedTile = {
            position: new THREE.Vector2(x, z),
            mesh: markedTileMesh
        };

        this.ui.updateMarkedTileStatus("Tile marked at " + Math.round(x) + ", " + Math.round(z));
    }

    captureCube() {
        if (!this.markedTile) return;

        // Check if there's a cube above the marked tile
        const cubesToCapture = this.level.getCubesAtPosition(
            this.markedTile.position.x,
            this.markedTile.position.y
        );

        if (cubesToCapture.length > 0) {
            // Process each cube at the marked position
            cubesToCapture.forEach(cube => {
                if (cube.type === 'normal') {
                    // Capture normal cube (good)
                    this.captureNormalCube(cube);
                } else if (cube.type === 'forbidden') {
                    // Capture forbidden cube (bad)
                    this.captureForbiddenCube(cube);
                } else if (cube.type === 'advantage') {
                    // Capture advantage cube (special)
                    this.captureAdvantageCube(cube);
                }
            });
        }

        // Remove marked tile
        this.scene.remove(this.markedTile.mesh);
        this.markedTile = null;
        this.ui.updateMarkedTileStatus("No tile marked");
    }

    captureNormalCube(cube) {
        // Add score
        this.score += 100;
        this.ui.updateScore(this.score);

        // Remove cube
        this.level.removeCube(cube);

        // Create capture effect
        this.createCaptureEffect(cube.mesh.position);
    }

    captureForbiddenCube(cube) {
        // Penalty for capturing forbidden cube
        this.level.shrinkPlatform();

        // Remove cube
        this.level.removeCube(cube);

        // Create capture effect (red color)
        this.createCaptureEffect(cube.mesh.position, 0xff0000);
    }

    captureAdvantageCube(cube) {
        // Set as active advantage
        this.activatedAdvantage = {
            position: new THREE.Vector2(
                cube.mesh.position.x,
                cube.mesh.position.z
            )
        };

        // Add score
        this.score += 50;
        this.ui.updateScore(this.score);

        // Remove cube
        this.level.removeCube(cube);

        // Create capture effect (green color)
        this.createCaptureEffect(cube.mesh.position, 0x00ff00);
    }

    activateAdvantage() {
        if (!this.activatedAdvantage) return;

        // Create 3x3 area effect
        const center = this.activatedAdvantage.position;
        const areaSize = 1;

        // Get all cubes in the 3x3 area
        const capturedCubes = [];

        for (let x = center.x - areaSize; x <= center.x + areaSize; x++) {
            for (let z = center.y - areaSize; z <= center.y + areaSize; z++) {
                const cubes = this.level.getCubesAtPosition(x, z);
                capturedCubes.push(...cubes);
            }
        }

        // Process each cube in the advantage area
        capturedCubes.forEach(cube => {
            if (cube.type === 'normal') {
                this.score += 100;
                this.level.removeCube(cube);
            } else if (cube.type === 'advantage') {
                this.score += 50;
                this.level.removeCube(cube);
            }
            // Don't capture forbidden cubes with advantage
        });

        // Create advantage effect
        this.createAdvantageEffect(
            new THREE.Vector3(center.x, 0.1, center.y),
            areaSize
        );

        // Update score
        this.ui.updateScore(this.score);

        // Reset advantage
        this.activatedAdvantage = null;
    }

    createCaptureEffect(position, color = 0x0099ff) {
        // Create effect
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.7
        });

        const effect = new THREE.Mesh(geometry, material);
        effect.position.copy(position);
        this.scene.add(effect);

        // Animation for the effect
        const startScale = 1;
        const endScale = 2;
        const duration = 0.5;
        let elapsed = 0;

        const animate = () => {
            elapsed += 0.016;
            const progress = elapsed / duration;

            if (progress < 1) {
                const scale = startScale + (endScale - startScale) * progress;
                effect.scale.set(scale, scale, scale);
                effect.material.opacity = 0.7 * (1 - progress);

                requestAnimationFrame(animate);
            } else {
                this.scene.remove(effect);
            }
        };

        animate();
    }

    createAdvantageEffect(position, size) {
        // Create effect
        const geometry = new THREE.BoxGeometry(size * 2 + 1, 0.5, size * 2 + 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5
        });

        const effect = new THREE.Mesh(geometry, material);
        effect.position.copy(position);
        this.scene.add(effect);

        // Animation for the effect
        const startScale = 1;
        const endScale = 1.5;
        const duration = 1.0;
        let elapsed = 0;

        const animate = () => {
            elapsed += 0.016;
            const progress = elapsed / duration;

            if (progress < 1) {
                const scale = startScale + (endScale - startScale) * progress;
                effect.scale.set(scale, scale, scale);
                effect.material.opacity = 0.5 * (1 - progress);

                requestAnimationFrame(animate);
            } else {
                this.scene.remove(effect);
            }
        };

        animate();
    }

    startLevel(levelNumber) {
        // Reset state
        this.markedTile = null;
        this.activatedAdvantage = null;

        // Configure level based on level number
        this.settings.cubeSpeed = 1.5 + (levelNumber * 0.25);
        this.settings.initialCubeCount = 10 + (levelNumber * 2);

        // Generate level
        this.level.generateLevel(levelNumber);

        // Reset player position
        this.player.resetPosition();

        // Update UI
        this.ui.updateLevel(levelNumber);
        this.ui.updateCubesLeft(this.level.getRemainingCubes());
    }

    nextLevel() {
        this.currentLevel++;

        // Check for payment after 7 plays
        this.playCount++;
        if (this.playCount >= 7) {
            this.paymentModal.show();
            return;
        }

        this.startLevel(this.currentLevel);
    }

    endGame() {
        this.gameOver = true;
        this.ui.showGameOver(this.score);
    }

    restart() {
        this.score = 0;
        this.currentLevel = 1;
        this.gameOver = false;

        // Clear existing level
        this.level.clearLevel();

        // Start new level
        this.startLevel(this.currentLevel);

        // Hide game over screen
        this.ui.hideGameOver();
    }

    update() {
        if (this.paused || this.gameOver) return;

        const delta = this.clock.getDelta();

        // Update level
        this.level.update(delta);

        // Check for level completion
        if (this.level.isLevelComplete()) {
            this.nextLevel();
        }

        // Check for game over
        if (this.level.isGameOver()) {
            this.endGame();
        }

        // Update UI
        this.ui.updateCubesLeft(this.level.getRemainingCubes());
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        // Update game state
        this.update();

        // Render scene
        this.renderer.render(this.scene, this.camera);
    }

}
`;

// Cube.js
const cubeJs = `
import \* as THREE from 'three';

export class Cube {
constructor(game, type, x, z) {
this.game = game;
this.type = type; // 'normal', 'forbidden', or 'advantage'
this.size = 1;
this.mesh = null;

        // Create cube mesh
        this.createMesh(x, z);
    }

    createMesh(x, z) {
        const geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
        let material;

        // Set material based on cube type
        switch(this.type) {
            case 'normal':
                material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                break;
            case 'forbidden':
                material = new THREE.MeshLambertMaterial({ color: 0x000000 });
                break;
            case 'advantage':
                material = new THREE.MeshLambertMaterial({
                    color: 0x00ff00,
                    emissive: 0x003300
                });
                break;
        }

        // Create mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, this.size / 2, z);
        this.mesh.castShadow = true;

        // Add to scene
        this.game.scene.add(this.mesh);
    }

    update(delta) {
        // Move cube towards player
        const speed = this.game.settings.cubeSpeed * delta;
        this.mesh.position.z -= speed;

        // Check for collision with player
        this.checkPlayerCollision();
    }

    checkPlayerCollision() {
        const playerPos = this.game.player.getPosition();
        const cubePos = this.mesh.position;

        // Check if cube overlaps with player
        if (Math.abs(playerPos.x - cubePos.x) < 0.8 &&
            Math.abs(playerPos.z - cubePos.z) < 0.8) {
            // Player got crushed by cube
            this.game.endGame();
        }
    }

}
`;

// UI.js
const uiJs = `
export class UI {
constructor(game) {
this.game = game;
this.scoreElement = document.getElementById('score');
this.levelElement = document.getElementById('level');
this.cubesLeftElement = document.getElementById('cubes-left');
this.markedTileElement = document.getElementById('markedTile');
this.gameOverScreen = document.getElementById('gameOverScreen');
this.finalScoreElement = document.getElementById('finalScore');
this.restartButton = document.getElementById('restartButton');

        // Add event listeners
        this.restartButton.addEventListener('click', () => {
            this.game.restart();
        });
    }

    updateScore(score) {
        this.scoreElement.textContent = \`Score: \${score}\`;
    }

    updateLevel(level) {
        this.levelElement.textContent = \`Level: \${level}\`;
    }

    updateCubesLeft(count) {
        this.cubesLeftElement.textContent = \`Cubes: \${count}\`;
    }

    updateMarkedTileStatus(status) {
        this.markedTileElement.textContent = status;
    }

    showGameOver(score) {
        this.finalScoreElement.textContent = \`Your score: \${score}\`;
        this.gameOverScreen.style.display = 'block';
    }

    hideGameOver() {
        this.gameOverScreen.style.display = 'none';
    }

}
`;

// PaymentModal.js
const paymentModalJs = `
export class PaymentModal {
constructor(game) {
this.game = game;
this.modal = document.getElementById('payment-modal');
this.closeButton = document.querySelector('.close');
this.payButton = document.getElementById('pay-button');

        // Add event listeners
        this.closeButton.addEventListener('click', () => this.hide());
        this.payButton.addEventListener('click', () => this.processPayment());
    }

    show() {
        this.modal.style.display = 'block';
    }

    hide() {
        this.modal.style.display = 'none';
    }

    processPayment() {
        // Mock payment processing
        alert('Thank you for your purchase! Enjoy the full game!');

        // Hide modal
        this.hide();

        // Reset play count
        this.game.playCount = 0;

        // Continue to next level
        this.game.startLevel(this.game.currentLevel);
    }

}
`;

// Player.js
const playerJs = `
import \* as THREE from 'three';

export class Player {
constructor(game) {
this.game = game;
this.mesh = null;
this.position = {
x: 0,
z: 0
};
this.size = 0.3;
this.moveSpeed = 0.2;
this.lastMoveTime = 0;
this.moveCooldown = 150; // ms

        this.init();
    }

    init() {
        // Create player mesh
        const geometry = new THREE.CapsuleGeometry(this.size / 2, this.size, 2, 8);
        const material = new THREE.MeshLambertMaterial({ color: 0xffff00 });
        this.mesh = new THREE.Mesh(geometry, material);

        // Position player
        this.resetPosition();

        // Add to scene
        this.game.scene.add(this.mesh);
    }

    resetPosition() {
        // Place player at the start of the platform
        const stageWidth = this.game.settings.stageWidth;
        const stageLength = this.game.settings.stageLength;

        this.position.x = 0;
        this.position.z = 1; // Near the start

        this.updateMeshPosition();
    }

    updateMeshPosition() {
        if (this.mesh) {
            this.mesh.position.set(
                this.position.x,
                this.size * 0.7, // Half height + small gap
                this.position.z
            );
        }
    }

    move(direction) {
        // Prevent rapid movement
        const now = Date.now();
        if (now - this.lastMoveTime < this.moveCooldown) {
            return;
        }
        this.lastMoveTime = now;

        // Get current position
        const { x, z } = this.position;
        const stageWidth = this.game.settings.stageWidth;
        const stageLength = this.game.settings.stageLength;

        // Calculate new position based on direction
        let newX = x;
        let newZ = z;

        switch(direction) {
            case 'forward':
                newZ = z + 1;
                break;
            case 'backward':
                newZ = z - 1;
                break;
            case 'left':
                newX = x - 1;
                break;
            case 'right':
                newX = x + 1;
                break;
        }

        // Check boundaries
        const halfWidth = Math.floor(stageWidth / 2);
        if (newX < -halfWidth || newX > halfWidth) {
            return;
        }

        if (newZ < 0 || newZ >= stageLength) {
            return;
        }

        // Check if the platform exists at this position
        if (!this.game.level.isPlatformAt(newX, newZ)) {
            return;
        }

        // Move player
        this.position.x = newX;
        this.position.z = newZ;

        // Update mesh position
        this.updateMeshPosition();
    }

    getPosition() {
        return {
            x: this.position.x,
            z: this.position.z
        };
    }

}
`;

// Level.js
const levelJs = `
import \* as THREE from 'three';
import { Cube } from './Cube.js';

export class Level {
constructor(game) {
this.game = game;
this.platform = [];
this.cubes = [];
this.waveIndex = 0;
this.waveTime = 0;
this.wavesRemaining = 0;

        // Platform properties
        this.platformMesh = null;
        this.platformWidth = 0;
        this.platformLength = 0;

        // Level state
        this.levelComplete = false;
        this.gameOver = false;
    }

    createPlatform() {
        const width = this.game.settings.stageWidth;
        const length = this.game.settings.stageLength;

        // Store dimensions
        this.platformWidth = width;
        this.platformLength = length;

        // Create platform geometry
        const geometry = new THREE.BoxGeometry(width, 0.5, length);
        const material = new THREE.MeshLambertMaterial({ color: 0x444444 });

        // Create mesh
        this.platformMesh = new THREE.Mesh(geometry, material);
        this.platformMesh.position.set(0, -0.25, length / 2 - 0.5);
        this.platformMesh.receiveShadow = true;

        // Add to scene
        this.game.scene.add(this.platformMesh);

        // Create platform grid for gameplay
        this.platform = [];

        for (let x = -Math.floor(width / 2); x <= Math.floor(width / 2); x++) {
            for (let z = 0; z < length; z++) {
                this.platform.push({ x, z, exists: true });
            }
        }
    }

    generateLevel(levelNumber) {
        // Clear previous level
        this.clearLevel();

        // Calculate wave count based on level
        this.wavesRemaining = 2 + Math.min(levelNumber, 8);

        // Generate first wave
        this.generateWave();
    }

    generateWave() {
        if (this.wavesRemaining <= 0) {
            this.levelComplete = true;
            return;
        }

        this.wavesRemaining--;
        this.waveIndex++;

        // Wave properties based on level
        const cubeCount = this.game.settings.initialCubeCount;
        const width = this.game.settings.stageWidth;
        const level = this.game.currentLevel;

        // Calculate cube distribution
        let normalCount = Math.floor(cubeCount * 0.7);  // 70% normal
        let forbiddenCount = Math.floor(cubeCount * 0.2);  // 20% forbidden
        let advantageCount = Math.floor(cubeCount * 0.1);  // 10% advantage

        // Ensure at least one of each type (for higher levels)
        if (level >= 2 && forbiddenCount === 0) forbiddenCount = 1;
        if (level >= 3 && advantageCount === 0) advantageCount = 1;

        // Create cubes
        const startZ = this.platformLength + 2;  // Start beyond platform
        const halfWidth = Math.floor(width / 2);

        // Precalculate positions without duplicates
        const positions = [];
        for (let x = -halfWidth; x <= halfWidth; x++) {
            for (let z = startZ; z < startZ + 3; z++) {
                positions.push({ x, z });
            }
        }

        // Shuffle positions
        for (let i = positions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [positions[i], positions[j]] = [positions[j], positions[i]];
        }

        // Place normal cubes
        for (let i = 0; i < normalCount && i < positions.length; i++) {
            const { x, z } = positions[i];
            this.createCube('normal', x, z);
        }

        // Place forbidden cubes
        for (let i = normalCount; i < normalCount + forbiddenCount && i < positions.length; i++) {
            const { x, z } = positions[i];
            this.createCube('forbidden', x, z);
        }

        // Place advantage cubes
        for (let i = normalCount + forbiddenCount; i < normalCount + forbiddenCount + advantageCount && i < positions.length; i++) {
            const { x, z } = positions[i];
            this.createCube('advantage', x, z);
        }
    }

    createCube(type, x, z) {
        const cube = new Cube(this.game, type, x, z);
        this.cubes.push(cube);
    }

    update(delta) {
        // Update cubes
        for (let i = this.cubes.length - 1; i >= 0; i--) {
            const cube = this.cubes[i];

            // Update cube
            cube.update(delta);

            // Check if cube fell off
            if (cube.mesh.position.z < -2) {
                // Handle cube falling off
                if (cube.type === 'normal') {
                    // Player missed a normal cube
                    // Potential penalty here
                }

                // Remove cube
                this.removeCube(cube);
            }
        }

        // Update wave timer
        this.waveTime += delta;

        // Generate new wave if needed
        if (this.cubes.length === 0 && this.wavesRemaining > 0) {
            this.generateWave();
        }
    }

    removeCube(cube) {
        // Remove from scene
        this.game.scene.remove(cube.mesh);

        // Remove from array
        const index = this.cubes.indexOf(cube);
        if (index !== -1) {
            this.cubes.splice(index, 1);
        }
    }

    clearLevel() {
        // Remove all cubes
        for (let i = this.cubes.length - 1; i >= 0; i--) {
            const cube = this.cubes[i];
            this.game.scene.remove(cube.mesh);
        }

        // Clear arrays
        this.cubes = [];

        // Reset state
        this.waveIndex = 0;
        this.waveTime = 0;
        this.levelComplete = false;
        this.gameOver = false;
    }

    shrinkPlatform() {
        // Shrink platform by removing a row
        const row = Math.max(0, this.platformLength - 1);

        // Remove cubes on that row
        for (let i = this.cubes.length - 1; i >= 0; i--) {
            const cube = this.cubes[i];
            if (Math.round(cube.mesh.position.z) === row) {
                this.removeCube(cube);
            }
        }

        // Update platform data
        for (let i = this.platform.length - 1; i >= 0; i--) {
            const tile = this.platform[i];
            if (tile.z === row) {
                tile.exists = false;
            }
        }

        // Check if player is affected
        const playerPos = this.game.player.getPosition();
        if (Math.round(playerPos.z) === row) {
            this.gameOver = true;
        }

        // Update platform mesh (visual)
        // For simplicity in the MVP, we just change the platform color
        this.platformMesh.material.color.set(0x333333);
    }

    isPlatformAt(x, z) {
        // Check if platform exists at this position
        for (const tile of this.platform) {
            if (tile.x === x && tile.z === z && tile.exists) {
                return true;
            }
        }
        return false;
    }

    getCubesAtPosition(x, z) {
        // Find all cubes at a specific position
        return this.cubes.filter(cube => {
            // Use approximate position to handle moving cubes
            const cubeX = Math.round(cube.mesh.position.x);
            const cubeZ = Math.round(cube.mesh.position.z);

            return cubeX === Math.round(x) && cubeZ === Math.round(z);
        });
    }

    getRemainingCubes() {
        return this.cubes.filter(cube => cube.type === 'normal').length;
    }

    isLevelComplete() {
        // Level is complete when all normal cubes are cleared
        // and there are no more waves
        return this.levelComplete ||
               (this.getRemainingCubes() === 0 && this.wavesRemaining === 0);
    }

    isGameOver() {
        return this.gameOver;
    }

================
File: .cursor/docs/MVP part2.md
================
Absolutely, we can go through each of the five next steps to enhance your I.Q.: Intelligent Qube-inspired game MVP together! I’ll guide you step-by-step, ensuring each addition improves the gameplay while keeping it engaging and smooth. We’ll tackle one step at a time, with clear explanations, code examples, and reasoning for why each enhancement matters. Let’s get started!
Step 1: Add Visual Feedback
Objective
Enhance the player’s understanding of game states by adding visual cues for marked spots and cube captures.
Why It Matters
Visual feedback helps players instantly see the results of their actions, reducing confusion and keeping them immersed in the game—a key part of maintaining a "flow state."
How to Implement
Marked Spots: When the player marks a spot on the grid, change that grid cube’s color (e.g., to green) to show it’s armed.
Cube Captures: When a cube is captured, add a short animation (e.g., shrinking or fading) to make the capture feel rewarding.
Code Example
Here’s how you can add this in a Three.js-based game:
javascript
// In game.js
let markedCube = null; // Track the currently marked cube

// Function to mark a spot
function markSpot(x, z) {
// Reset the previous marked cube’s color
if (markedCube) {
markedCube.material.color.set(0xaaaaaa); // Default grid color (gray)
}

// Find and mark the new spot
const index = x + z \* gridSize; // Assuming gridSize is defined
markedCube = grid[index]; // grid is your array of grid cubes
markedCube.material.color.set(0x00ff00); // Green for marked
markedSpot = { x, z }; // Store the marked position
}

// Function to capture a cube
function captureCube() {
if (!markedSpot || !markedCube) return;
const { x, z } = markedSpot;

// Find the cube at the marked spot
const cube = rollingCubes.find(c =>
Math.abs(c.position.x - x) < 0.1 && Math.abs(c.position.z - z) < 0.1
);

if (cube) {
// Update score based on cube type
if (cube.userData.type === 'normal') {
score += 1;
} else if (cube.userData.type === 'forbidden') {
fallenCubes += 1; // Track mistakes
}

    // Animate the cube shrinking before removal
    new TWEEN.Tween(cube.scale)
      .to({ x: 0, y: 0, z: 0 }, 300) // Shrink over 300ms
      .onComplete(() => {
        scene.remove(cube); // Remove from scene
        rollingCubes.splice(rollingCubes.indexOf(cube), 1); // Remove from array
      })
      .start();

    // Reset the marked spot
    markedCube.material.color.set(0xaaaaaa); // Back to gray
    markedSpot = null;
    markedCube = null;
    updateScore(); // Update UI

}
}

// Add TWEEN.js to your HTML
// <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js"></script>

// In your animation loop
function animate() {
requestAnimationFrame(animate);
TWEEN.update(); // Update animations
renderer.render(scene, camera);
}
Setup Notes
Dependencies: Include TWEEN.js for animations (see the HTML script tag above).
Assumptions: grid is an array of your grid cubes, rollingCubes is an array of moving cubes, and scene, renderer, and camera are set up in Three.js.
Result
Players will see a green highlight when they mark a spot and a satisfying shrink effect when they capture a cube, making the game feel more responsive and polished.
Step 2: Expand Cube Types
Objective
Add a new cube type—advantage cubes—that, when captured, let the player clear a 3x3 area of cubes.
Why It Matters
More cube types add variety and strategy, keeping the game fresh and giving players new ways to handle tough situations.
How to Implement
Advantage Cubes: Blue cubes that trigger a 3x3 clear when captured.
Capture Mechanic: Store the advantage and let the player activate it with a key (e.g., 'A').
Code Example
javascript
// In your cube creation function (e.g., createRollingCube)
function createRollingCube(x, type) {
// Randomly assign type if not specified
const cubeType = type || (Math.random() < 0.7 ? 'normal' : Math.random() < 0.5 ? 'forbidden' : 'advantage');
const color = cubeType === 'normal' ? 0x00ff00 : cubeType === 'forbidden' ? 0xff0000 : 0x0000ff; // Green, red, blue
const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
const material = new THREE.MeshStandardMaterial({ color });
const cube = new THREE.Mesh(geometry, material);
cube.position.set(x, 0.5, 5); // Starting position
cube.userData.type = cubeType;
scene.add(cube);
rollingCubes.push(cube);
}

// Update captureCube function
let advantagePosition = null; // Store the advantage cube’s position

function captureCube() {
if (!markedSpot || !markedCube) return;
const { x, z } = markedSpot;
const cube = rollingCubes.find(c =>
Math.abs(c.position.x - x) < 0.1 && Math.abs(c.position.z - z) < 0.1
);

if (cube) {
if (cube.userData.type === 'advantage') {
advantagePosition = { x: cube.position.x, z: cube.position.z };
// Optionally, show a UI hint like "Press A to clear 3x3!"
} else if (cube.userData.type === 'normal') {
score += 1;
} else if (cube.userData.type === 'forbidden') {
fallenCubes += 1;
}

    new TWEEN.Tween(cube.scale)
      .to({ x: 0, y: 0, z: 0 }, 300)
      .onComplete(() => {
        scene.remove(cube);
        rollingCubes.splice(rollingCubes.indexOf(cube), 1);
      })
      .start();

    markedCube.material.color.set(0xaaaaaa);
    markedSpot = null;
    markedCube = null;
    updateScore();

}
}

// Function to clear a 3x3 area
function clearArea(centerX, centerZ) {
const minX = Math.max(0, Math.round(centerX) - 1);
const maxX = Math.min(gridSize - 1, Math.round(centerX) + 1);
const minZ = Math.max(0, Math.round(centerZ) - 1);
const maxZ = Math.min(gridSize - 1, Math.round(centerZ) + 1);

rollingCubes.forEach(cube => {
const cx = Math.round(cube.position.x);
const cz = Math.round(cube.position.z);
if (cx >= minX && cx <= maxX && cz >= minZ && cz <= maxZ) {
scene.remove(cube);
rollingCubes.splice(rollingCubes.indexOf(cube), 1);
if (cube.userData.type === 'normal') score += 1;
}
});
}

// Bind the clear action to a key
document.addEventListener('keydown', (event) => {
if (event.key === 'a' && advantagePosition) {
clearArea(advantagePosition.x, advantagePosition.z);
advantagePosition = null;
updateScore();
}
});
Result
Players can now capture blue advantage cubes and press 'A' to clear a 3x3 area, adding a strategic tool to manage overwhelming waves.
Step 3: Improve Procedural Generation
Objective
Create more varied cube patterns using templates to keep gameplay interesting.
Why It Matters
Varied patterns prevent the game from feeling repetitive, encouraging players to adapt and stay engaged.
How to Implement
Pattern Templates: Predefine cube arrangements (e.g., lines, clusters).
Wave Generation: Randomly pick and place patterns.
Code Example
javascript
// Define some simple patterns
const patterns = [
() => [
{ x: 0, type: 'normal' },
{ x: 1, type: 'normal' },
{ x: 2, type: 'normal' }
], // Horizontal line
() => [
{ x: 0, type: 'forbidden' },
{ x: 2, type: 'advantage' }
], // Spaced with advantage
];

// Wave generation function
let waveTimer = 0;
function generateWave(delta) {
waveTimer += delta;
if (waveTimer >= 2) { // Every 2 seconds
const pattern = patterns[Math.floor(Math.random() \* patterns.length)]();
const offset = Math.floor(Math.random() \* (gridSize - 3)); // Shift pattern
pattern.forEach(({ x, type }) => {
createRollingCube(x + offset, type);
});
waveTimer = 0;
}
}

// Call this in your animate loop
function animate() {
requestAnimationFrame(animate);
generateWave(delta); // Pass delta from a clock
TWEEN.update();
renderer.render(scene, camera);
}
Result
Waves now spawn in interesting patterns, making each wave visually and strategically distinct.
Step 4: Optimize Performance
Objective
Use instanced meshes to render many cubes efficiently.
Why It Matters
Smooth performance is essential for an infinite game; lag disrupts immersion.
How to Implement
Instanced Meshes: Render all cubes of each type with one mesh.
Update Logic: Adjust instance positions instead of individual objects.
Code Example
javascript
// Setup instanced meshes
const maxCubes = 100;
const normalCubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
const normalCubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const normalCubes = new THREE.InstancedMesh(normalCubeGeometry, normalCubeMaterial, maxCubes);
scene.add(normalCubes);
// Repeat for forbidden and advantage cubes

let normalCubeCount = 0;
function createRollingCube(x, type) {
if (type === 'normal' && normalCubeCount < maxCubes) {
const dummy = new THREE.Object3D();
dummy.position.set(x, 0.5, 5);
dummy.updateMatrix();
normalCubes.setMatrixAt(normalCubeCount, dummy.matrix);
normalCubes.instanceMatrix.needsUpdate = true;
normalCubeCount++;
}
// Add logic for other types
}

// Update positions in animate (simplified)
function animate() {
// Update instance positions based on your game logic
normalCubes.instanceMatrix.needsUpdate = true;
}
Result
The game can handle more cubes without performance drops, ensuring a seamless experience.
Step 5: Add Multiplayer
Objective
Add a leaderboard to introduce competition.
Why It Matters
Leaderboards motivate players to improve and replay the game.
How to Implement
Backend: Use Node.js and SQLite for score storage.
Frontend: Submit scores and show the leaderboard.
Code Example
Server (server.js):
javascript
const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const app = express();
const db = new sqlite3.Database(':memory:');

db.serialize(() => {
db.run("CREATE TABLE scores (name TEXT, score INTEGER)");
});

app.use(express.json());
app.post('/submit-score', (req, res) => {
const { name, score } = req.body;
db.run("INSERT INTO scores (name, score) VALUES (?, ?)", [name, score], err => {
if (err) res.status(500).send('Error');
else res.send('Score submitted');
});
});

app.get('/leaderboard', (req, res) => {
db.all("SELECT name, score FROM scores ORDER BY score DESC LIMIT 10", [], (err, rows) => {
if (err) res.status(500).send('Error');
else res.json(rows);
});
});

app.listen(3000, () => console.log('Server on port 3000'));
Client (game.js):
javascript
// After game over
fetch('http://localhost:3000/submit-score', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ name: 'Player', score })
})
.then(() => {
fetch('http://localhost:3000/leaderboard')
.then(res => res.json())
.then(data => console.log('Leaderboard:', data));
});
Setup Notes
Install Node.js, then npm install express sqlite3.
Run node server.js before testing.
Result
Players can submit scores and see the top 10, adding a competitive edge.
Next Steps
Let me know when you’re ready to implement Step 1 or if you want to tweak anything! We’ll proceed at your pace through all five steps.

================
File: .cursor/docs/Node.js Express Server and Deployment Guide.md
================
// server.js
const express = require('express');
const path = require('path');
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files
app.use(express.static(path.join(\_\_dirname, 'public')));

app.get('/', (req, res) => {
res.sendFile(path.join(\_\_dirname, 'public', 'index.html'));
});

app.listen(PORT, () => {
console.log(`Intelligence Cube 3D running on port ${PORT}`);
});

// package.json
/_
{
"name": "intelligence-cube-3d",
"version": "1.0.0",
"description": "Intelligence Cube 3D game using Three.js",
"main": "server.js",
"scripts": {
"start": "node server.js",
"dev": "nodemon server.js"
},
"keywords": ["game", "threejs", "puzzle"],
"author": "",
"license": "MIT",
"dependencies": {
"express": "^4.18.2"
},
"devDependencies": {
"nodemon": "^2.0.22"
}
}
_/

// Deployment instructions for Render.com:
/\*

1. Create a GitHub repository and push your code:

   - Create a new repository on GitHub
   - Initialize git in your project folder: git init
   - Add your files: git add .
   - Commit: git commit -m "Initial commit"
   - Add remote: git remote add origin <your-repo-url>
   - Push: git push -u origin main

2. Sign up for Render.com:

   - Go to render.com and sign up or login
   - Connect your GitHub account

3. Create a new Web Service:

   - Click "New" and select "Web Service"
   - Select your repository
   - Configure settings:
     - Name: intelligence-cube-3d
     - Environment: Node
     - Build Command: npm install
     - Start Command: npm start
     - Select a free or paid plan

4. Add environment variables (if needed):

   - Go to your web service dashboard
   - Navigate to "Environment" tab
   - Add any required environment variables

5. Deploy:

   - Click "Create Web Service"
   - Render will automatically build and deploy your application
   - Once deployed, you can access your game at the provided URL

6. Setup Mock Payment Integration:

   - The mock payment is already implemented
   - After 7 game plays, the payment modal will appear
   - User can click "Pay $2.99" to continue
   - In a real implementation, you would integrate Stripe API:

7. Stripe Integration (for future implementation):
   - npm install stripe
   - Create a Stripe account and get API keys
   - Add to server.js:

```javascript
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

app.post('/create-checkout-session', async (req, res) => {
	const session = await stripe.checkout.sessions.create({
		payment_method_types: ['card'],
		line_items: [
			{
				price_data: {
					currency: 'usd',
					product_data: {
						name: 'Intelligence Cube 3D Full Version',
					},
					unit_amount: 299, // $2.99
				},
				quantity: 1,
			},
		],
		mode: 'payment',
		success_url: `${req.headers.origin}/success.html`,
		cancel_url: `${req.headers.origin}/`,
	});

	res.json({ id: session.id });
});
```

- Client-side implementation would use Stripe's checkout.js library
  \*/

// Folder Structure for Deployment:
/_
intelligence-cube-3d/
├── package.json
├── server.js
└── public/
├── index.html
├── main.js
├── game/
│ ├── Game.js
│ ├── Player.js
│ ├── Level.js
│ ├── Cube.js
│ ├── UI.js
│ └── PaymentModal.js
└── lib/
└── three.min.js (or use CDN)
_/

================
File: .cursor/docs/update1.md
================
you have 3 lives and when they are up, you are asked to buy via stripe

add an animation to when blocks get destoyed a white light effect

the green squares when they blow up they should blow all squares around it and it can activate chains, also an animation of a white blast to show how it destroys the blocks

black squares if you break lose 3 lines of cubes from the platform so the player has less room

have a little pop up explain the rules and keybaord

when you pass a level it adds to a line of cubes to the platform alongating it

lets make the blocks rotate on the ground as it goes towards the player rolling side to side and it can crush player

add a angled camara to the game that moves side to side fluidly gracefully

================
File: .gitignore
================
# Dependencies
/node_modules
npm-debug.log
yarn-debug.log
yarn-error.log

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# OS specific files
.DS_Store
Thumbs.db

# IDE specific files
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Build files
/dist
/build

================
File: deploy.ps1
================
$apiKey = "rnd_OTq0bxnl53bVpaAnU2qxYu5CdVNK"
$serviceName = "quantum-grid-neon-legacy"
$headers = @{
    Authorization = "Bearer $apiKey"
}

try {
    # First get the service ID
    $servicesResponse = Invoke-RestMethod -Method GET -Uri "https://api.render.com/v1/services" -Headers $headers
    $serviceId = ($servicesResponse | Where-Object { $_.service.name -eq $serviceName }).service.id
    
    if (-not $serviceId) {
        Write-Error "Service '$serviceName' not found"
        exit 1
    }
    
    # Now trigger a deploy with the service ID
    $uri = "https://api.render.com/v1/services/$serviceId/deploys"
    $response = Invoke-RestMethod -Method POST -Uri $uri -Headers $headers
    
    Write-Output "Deployment triggered successfully for $serviceName (ID: $serviceId)"
    Write-Output $response
} catch {
    Write-Error "Deployment failed: $_"
}

================
File: package.json
================
{
	"name": "quantum-grid-neon-legacy",
	"version": "1.0.0",
	"description": "Quantum Grid: Neon Legacy - A 3D puzzle game inspired by I.Q.: Intelligent Qube",
	"main": "server.js",
	"scripts": {
		"start": "node server.js",
		"dev": "nodemon server.js"
	},
	"keywords": [
		"game",
		"threejs",
		"puzzle",
		"quantum-grid",
		"neon-legacy"
	],
	"author": "",
	"license": "MIT",
	"dependencies": {
		"dotenv": "^16.4.7",
		"express": "^4.18.2",
		"stripe": "^12.18.0",
		"three": "^0.157.0"
	},
	"devDependencies": {
		"nodemon": "^2.0.22"
	}
}

================
File: public/game/Cube.js
================
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

export class Cube {
	constructor(game, type, x, z) {
		this.game = game;
		this.type = type; // 'normal', 'forbidden', or 'advantage'
		this.size = 1;
		this.mesh = null;
		this.rotation = {
			speed: (Math.random() - 0.5) * 0.02, // Random rotation direction
			axis: new THREE.Vector3(
				Math.random() > 0.5 ? 1 : 0,
				0,
				Math.random() > 0.5 ? 1 : 0
			).normalize(),
		};

		// Create cube mesh
		this.createMesh(x, z);
	}

	createMesh(x, z) {
		const geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
		let material;

		// Enhanced materials with emissive properties for neon effect
		switch (this.type) {
			case 'red':
				material = new THREE.MeshStandardMaterial({
					color: 0xff0000,
					emissive: 0xff0000,
					emissiveIntensity: 0.5,
					metalness: 0.8,
					roughness: 0.2,
				});
				break;
			case 'green':
				material = new THREE.MeshStandardMaterial({
					color: 0x00ff00,
					emissive: 0x00ff00,
					emissiveIntensity: 0.5,
					metalness: 0.8,
					roughness: 0.2,
				});
				break;
			case 'blue':
				material = new THREE.MeshStandardMaterial({
					color: 0x0000ff,
					emissive: 0x0000ff,
					emissiveIntensity: 0.5,
					metalness: 0.8,
					roughness: 0.2,
				});
				break;
			case 'yellow':
				material = new THREE.MeshStandardMaterial({
					color: 0xffff00,
					emissive: 0xffff00,
					emissiveIntensity: 0.5,
					metalness: 0.8,
					roughness: 0.2,
				});
				break;
			case 'black':
				material = new THREE.MeshStandardMaterial({
					color: 0x000000,
					emissive: 0x330033,
					emissiveIntensity: 0.3,
					metalness: 0.9,
					roughness: 0.1,
				});
				break;
			default:
				material = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					emissive: 0xffffff,
					emissiveIntensity: 0.3,
					metalness: 0.8,
					roughness: 0.2,
				});
		}

		// Add wireframe overlay for neon grid effect
		const wireframe = new THREE.LineSegments(
			new THREE.EdgesGeometry(geometry),
			new THREE.LineBasicMaterial({
				color: this.getWireframeColor(),
				linewidth: 2,
			})
		);

		// Create the main mesh
		this.mesh = new THREE.Mesh(geometry, material);
		this.mesh.position.set(x, this.size / 2, z);
		this.mesh.castShadow = true;
		this.mesh.receiveShadow = true;

		// Add wireframe as child of the mesh
		this.mesh.add(wireframe);

		// Add to scene
		this.game.scene.add(this.mesh);
	}

	getWireframeColor() {
		switch (this.type) {
			case 'red':
				return 0xff5555;
			case 'green':
				return 0x55ff55;
			case 'blue':
				return 0x5555ff;
			case 'yellow':
				return 0xffff55;
			case 'black':
				return 0xff00ff; // Purple wireframe for black cubes
			default:
				return 0xffffff;
		}
	}

	update(delta) {
		// Move cube towards player
		const speed = this.game.settings.cubeSpeed * delta;
		this.mesh.position.z -= speed;

		// Roll the cube as it moves
		this.rollCube(speed);

		// Apply additional rotation for visual flair
		this.mesh.rotateOnAxis(this.rotation.axis, this.rotation.speed);

		// Check for collision with player
		this.checkPlayerCollision();
	}

	rollCube(distance) {
		// Calculate rotation based on distance moved
		// A full rotation is 2π radians, which should occur when the cube moves a distance equal to its circumference
		// For a unit cube, one face is 1 unit, so a 90-degree rotation per unit of distance
		const rotationAmount = (Math.PI / 2) * distance;

		// Determine rotation axis (x-axis for movement along z)
		this.mesh.rotateX(rotationAmount);
	}

	checkPlayerCollision() {
		const playerPos = this.game.player.getPosition();
		const cubePos = this.mesh.position;

		// Check if cube overlaps with player
		if (
			Math.abs(playerPos.x - cubePos.x) < 0.8 &&
			Math.abs(playerPos.z - cubePos.z) < 0.8
		) {
			// Player got crushed by cube
			this.game.endGame();
		}
	}
}

================
File: public/game/Game.js
================
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
import { Player } from './Player.js';
import { Level } from './Level.js';
import { UI } from './UI.js';
import { PaymentModal } from './PaymentModal.js';

export class Game {
	constructor() {
		this.scene = null;
		this.camera = null;
		this.renderer = null;
		this.player = null;
		this.level = null;
		this.ui = null;
		this.clock = new THREE.Clock();
		this.score = 0;
		this.currentLevel = 1;
		this.gameStarted = false;
		this.gameOver = false;
		this.paymentModal = null;
		this.playCount = 0;

		// Game state
		this.paused = false;
		this.markedTile = null;
		this.activatedAdvantage = null;
		this.lives = 3;
		this.paid = false;

		// Settings
		this.settings = {
			stageWidth: 10,
			stageLength: 15,
			cubeSpeed: 2.0,
			initialCubeCount: 15,
		};

		// Camera animation properties
		this.cameraAnimation = {
			active: false,
			speed: 0.5,
			amplitude: 5,
			angle: 0,
			basePosition: new THREE.Vector3(0, 20, 30),
			lookAtPosition: new THREE.Vector3(0, 0, 0),
		};

		// Post-processing properties
		this.composer = null;
		this.bloomPass = null;

		// Initialize the game
		this.init();
	}

	init() {
		// Create scene
		this.scene = new THREE.Scene();

		// Create camera
		this.camera = new THREE.PerspectiveCamera(
			75,
			window.innerWidth / window.innerHeight,
			0.1,
			1000
		);
		this.camera.position.copy(this.cameraAnimation.basePosition);
		this.camera.lookAt(this.cameraAnimation.lookAtPosition);

		// Create renderer
		this.setupRenderer();
		this.setupSkybox();
		this.setupPostProcessing();

		// Add lights
		this.setupLights();

		// Initialize components
		this.ui = new UI(this);
		this.level = new Level(this);
		this.player = new Player(this);

		// Add event listeners
		window.addEventListener('resize', () => this.onWindowResize());
		document.addEventListener('keydown', (e) => this.handleKeyDown(e));

		// Initialize Stripe
		if (typeof Stripe !== 'undefined') {
			this.stripe = Stripe('pk_test_your_stripe_key');
		}

		// Show start screen
		this.ui.showStartScreen();
	}

	setupRenderer() {
		this.renderer = new THREE.WebGLRenderer({ antialias: true });
		this.renderer.setSize(window.innerWidth, window.innerHeight);
		this.renderer.setClearColor(0x000000);
		this.renderer.shadowMap.enabled = true;
		document.body.appendChild(this.renderer.domElement);
	}

	setupSkybox() {
		// Create a procedural skybox with a gradient and stars
		const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);

		// Create materials for each face with a gradient from dark blue to black
		const materialArray = [];

		// Create a canvas for the texture
		const createGradientTexture = () => {
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const context = canvas.getContext('2d');

			// Create gradient
			const gradient = context.createLinearGradient(0, 0, 0, 512);
			gradient.addColorStop(0, '#000000');
			gradient.addColorStop(1, '#0a0a2a');

			// Fill with gradient
			context.fillStyle = gradient;
			context.fillRect(0, 0, 512, 512);

			// Add stars
			for (let i = 0; i < 100; i++) {
				const x = Math.random() * 512;
				const y = Math.random() * 512;
				const radius = Math.random() * 1.5;
				const opacity = Math.random() * 0.8 + 0.2;

				context.beginPath();
				context.arc(x, y, radius, 0, Math.PI * 2);
				context.fillStyle = `rgba(255, 255, 255, ${opacity})`;
				context.fill();
			}

			return canvas;
		};

		// Create textures for each face
		for (let i = 0; i < 6; i++) {
			const texture = new THREE.CanvasTexture(createGradientTexture());
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;

			const material = new THREE.MeshBasicMaterial({
				map: texture,
				side: THREE.BackSide,
			});

			materialArray.push(material);
		}

		// Create skybox mesh
		const skybox = new THREE.Mesh(skyboxGeometry, materialArray);
		this.scene.add(skybox);
	}

	setupPostProcessing() {
		// Import required modules
		import(
			'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/EffectComposer.js'
		).then((module) => {
			const { EffectComposer } = module;
			import(
				'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/RenderPass.js'
			).then((module) => {
				const { RenderPass } = module;
				import(
					'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/UnrealBloomPass.js'
				).then((module) => {
					const { UnrealBloomPass } = module;

					// Create composer
					this.composer = new EffectComposer(this.renderer);

					// Add render pass
					const renderPass = new RenderPass(this.scene, this.camera);
					this.composer.addPass(renderPass);

					// Add bloom pass
					const bloomParams = {
						exposure: 1,
						bloomStrength: 1.5,
						bloomThreshold: 0.2,
						bloomRadius: 0.5,
					};

					const bloomPass = new UnrealBloomPass(
						new THREE.Vector2(window.innerWidth, window.innerHeight),
						bloomParams.bloomStrength,
						bloomParams.bloomRadius,
						bloomParams.bloomThreshold
					);
					this.composer.addPass(bloomPass);
					this.bloomPass = bloomPass;
				});
			});
		});
	}

	setupLights() {
		// Ambient light for base illumination
		const ambientLight = new THREE.AmbientLight(0x111122, 0.4);
		this.scene.add(ambientLight);

		// Main directional light
		const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(5, 10, 7);
		directionalLight.castShadow = true;

		// Configure shadow properties
		directionalLight.shadow.mapSize.width = 2048;
		directionalLight.shadow.mapSize.height = 2048;
		directionalLight.shadow.camera.near = 0.5;
		directionalLight.shadow.camera.far = 50;
		directionalLight.shadow.camera.left = -15;
		directionalLight.shadow.camera.right = 15;
		directionalLight.shadow.camera.top = 15;
		directionalLight.shadow.camera.bottom = -15;

		this.scene.add(directionalLight);

		// Add colored point lights for neon effect
		const colors = [0xff00ff, 0x00ffff, 0xffff00];
		const positions = [
			[-10, 5, 5],
			[10, 5, -5],
			[0, 5, 10],
		];

		for (let i = 0; i < colors.length; i++) {
			const pointLight = new THREE.PointLight(colors[i], 0.6, 20);
			pointLight.position.set(...positions[i]);
			this.scene.add(pointLight);

			// Add light helper for debugging (uncomment if needed)
			// const helper = new THREE.PointLightHelper(pointLight, 0.5);
			// this.scene.add(helper);
		}
	}

	onWindowResize() {
		this.camera.aspect = window.innerWidth / window.innerHeight;
		this.camera.updateProjectionMatrix();
		this.renderer.setSize(window.innerWidth, window.innerHeight);

		// Update composer size if available
		if (this.composer) {
			this.composer.setSize(window.innerWidth, window.innerHeight);
		}
	}

	handleKeyDown(e) {
		if (this.paused || this.gameOver) return;

		const key = e.key.toLowerCase();

		if (key === 'escape') {
			this.paused = !this.paused;
			return;
		}

		if (this.paused) return;

		// Player movement
		if (key === 'w' || key === 'arrowup') {
			this.player.move('forward');
		} else if (key === 's' || key === 'arrowdown') {
			this.player.move('backward');
		} else if (key === 'a' || key === 'arrowleft') {
			this.player.move('right');
		} else if (key === 'd' || key === 'arrowright') {
			this.player.move('left');
		}

		// Mark/Capture cube
		if (key === ' ') {
			if (this.markedTile) {
				this.captureCube();
			} else {
				this.markTile();
			}
		}

		// Activate advantage cube
		if (key === 'r') {
			this.activateAdvantage();
		}

		// Toggle camera animation
		if (key === 'c') {
			this.toggleCameraAnimation();
		}
	}

	markTile() {
		// Can only mark one tile at a time
		if (this.markedTile) return;

		// Get player position
		const position = this.player.getPosition();
		const x = position.x;
		const z = position.z;

		// Create marked tile
		const geometry = new THREE.BoxGeometry(1, 0.1, 1);
		const material = new THREE.MeshBasicMaterial({
			color: 0x0099ff,
			transparent: true,
			opacity: 0.5,
		});

		const markedTileMesh = new THREE.Mesh(geometry, material);
		markedTileMesh.position.set(x, 0.05, z);
		this.scene.add(markedTileMesh);

		this.markedTile = {
			position: new THREE.Vector2(x, z),
			mesh: markedTileMesh,
		};

		this.ui.updateMarkedTileStatus(
			`Tile marked at ${Math.round(x)}, ${Math.round(z)}`
		);
	}

	captureCube() {
		if (!this.markedTile) return;

		// Check if there's a cube above the marked tile
		const cubesToCapture = this.level.getCubesAtPosition(
			this.markedTile.position.x,
			this.markedTile.position.y
		);

		if (cubesToCapture.length > 0) {
			// Process each cube at the marked position
			cubesToCapture.forEach((cube) => {
				if (cube.type === 'normal') {
					// Capture normal cube (good)
					this.captureNormalCube(cube);
				} else if (cube.type === 'forbidden') {
					// Capture forbidden cube (bad)
					this.captureForbiddenCube(cube);
				} else if (cube.type === 'advantage') {
					// Capture advantage cube (special)
					this.captureAdvantageCube(cube);
				}
			});
		}

		// Remove marked tile
		this.scene.remove(this.markedTile.mesh);
		this.markedTile = null;
		this.ui.updateMarkedTileStatus('No tile marked');
	}

	captureNormalCube(cube) {
		// Add score
		this.score += 100;
		this.ui.updateScore(this.score);

		// Remove cube
		this.level.removeCube(cube);

		// Create capture effect
		this.createCaptureEffect(cube.mesh.position);
	}

	captureForbiddenCube(cube) {
		// Penalty for capturing forbidden cube
		this.level.shrinkPlatform();

		// Remove cube
		this.level.removeCube(cube);

		// Create capture effect (red color)
		this.createCaptureEffect(cube.mesh.position, 0xff0000);
	}

	captureAdvantageCube(cube) {
		// Set as active advantage
		this.activatedAdvantage = {
			position: new THREE.Vector2(cube.mesh.position.x, cube.mesh.position.z),
		};

		// Add score
		this.score += 50;
		this.ui.updateScore(this.score);

		// Remove cube
		this.level.removeCube(cube);

		// Create capture effect (green color)
		this.createCaptureEffect(cube.mesh.position, 0x00ff00);
	}

	activateAdvantage() {
		if (!this.activatedAdvantage) return;

		// Create 3x3 area effect
		const center = this.activatedAdvantage.position;
		const areaSize = 1;

		// Get all cubes in the 3x3 area
		const capturedCubes = [];

		for (let x = center.x - areaSize; x <= center.x + areaSize; x++) {
			for (let z = center.y - areaSize; z <= center.y + areaSize; z++) {
				const cubes = this.level.getCubesAtPosition(x, z);
				capturedCubes.push(...cubes);
			}
		}

		// Process each cube in the advantage area
		capturedCubes.forEach((cube) => {
			if (cube.type === 'normal') {
				this.score += 100;
				this.level.removeCube(cube);
			} else if (cube.type === 'advantage') {
				this.score += 50;
				this.level.removeCube(cube);
			}
			// Don't capture forbidden cubes with advantage
		});

		// Create advantage effect
		this.createAdvantageEffect(
			new THREE.Vector3(center.x, 0.1, center.y),
			areaSize
		);

		// Update score
		this.ui.updateScore(this.score);

		// Reset advantage
		this.activatedAdvantage = null;
	}

	createCaptureEffect(position, color = 0x0099ff) {
		// Create effect
		const geometry = new THREE.BoxGeometry(1, 1, 1);
		const material = new THREE.MeshBasicMaterial({
			color: color,
			transparent: true,
			opacity: 0.7,
		});

		const effect = new THREE.Mesh(geometry, material);
		effect.position.copy(position);
		this.scene.add(effect);

		// Animation for the effect
		const startScale = 1;
		const endScale = 2;
		const duration = 0.5;
		let elapsed = 0;

		const animate = () => {
			elapsed += 0.016;
			const progress = elapsed / duration;

			if (progress < 1) {
				const scale = startScale + (endScale - startScale) * progress;
				effect.scale.set(scale, scale, scale);
				effect.material.opacity = 0.7 * (1 - progress);

				requestAnimationFrame(animate);
			} else {
				this.scene.remove(effect);
			}
		};

		animate();
	}

	createAdvantageEffect(position, size) {
		// Create effect
		const geometry = new THREE.BoxGeometry(size * 2 + 1, 0.5, size * 2 + 1);
		const material = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.5,
		});

		const effect = new THREE.Mesh(geometry, material);
		effect.position.copy(position);
		this.scene.add(effect);

		// Animation for the effect
		const startScale = 1;
		const endScale = 1.5;
		const duration = 1.0;
		let elapsed = 0;

		const animate = () => {
			elapsed += 0.016;
			const progress = elapsed / duration;

			if (progress < 1) {
				const scale = startScale + (endScale - startScale) * progress;
				effect.scale.set(scale, scale, scale);
				effect.material.opacity = 0.5 * (1 - progress);

				requestAnimationFrame(animate);
			} else {
				this.scene.remove(effect);
			}
		};

		animate();
	}

	startGame() {
		// Reset game state
		this.score = 0;
		this.currentLevel = 1;
		this.gameOver = false;
		this.gameStarted = true;
		this.playCount++;
		this.lives = 3;

		// Update UI
		this.ui.updateScore(this.score);
		this.ui.updateLevel(this.currentLevel);
		this.ui.updateLives(this.lives);

		// Start the game loop
		this.animate();

		// Generate the first level
		this.level.generateLevel(this.currentLevel);
	}

	restartGame() {
		// Check if player has reached play limit
		if (this.playCount >= 3 && !this.paid) {
			this.ui.showPaymentModal();
			return;
		}

		// Reset game state
		this.startGame();
	}

	endGame() {
		this.lives--;
		this.ui.updateLives(this.lives);

		if (this.lives <= 0) {
			this.gameOver = true;
			this.gameStarted = false;

			// First show game over screen
			this.ui.showGameOverScreen(this.score);

			// Then show payment modal if play count is high enough
			if (this.playCount >= 3 && !this.paid) {
				setTimeout(() => {
					this.ui.showPaymentModal();
				}, 1500);
			}
		} else {
			// Player still has lives left, reset position and continue
			this.player.resetPosition();
		}
	}

	cancelPayment() {
		this.ui.hidePaymentModal();
	}

	handlePayment() {
		// Create a checkout session
		fetch('/create-checkout-session', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				price: 'price_your_price_id',
			}),
		})
			.then((response) => response.json())
			.then((session) => {
				return this.stripe.redirectToCheckout({ sessionId: session.id });
			})
			.then((result) => {
				if (result.error) {
					console.error(result.error.message);
				}
			})
			.catch((error) => {
				console.error('Error:', error);
			});
	}

	update() {
		if (this.paused || this.gameOver) return;

		const delta = this.clock.getDelta();

		// Update camera position if animation is enabled
		if (this.cameraAnimation && this.cameraAnimation.active) {
			this.updateCameraPosition(delta);
		}

		// Update player
		if (this.player) {
			this.player.update(delta);
		}

		// Update level
		this.level.update(delta);

		// Check for level completion
		if (this.level.isLevelComplete()) {
			this.nextLevel();
		}

		// Check for game over
		if (this.level.isGameOver()) {
			this.endGame();
		}

		// Update UI
		this.ui.updateCubesLeft(this.level.getRemainingCubes());

		// Update post-processing effects
		if (this.composer) {
			this.composer.render();
		} else {
			this.renderer.render(this.scene, this.camera);
		}
	}

	updateCameraPosition(delta) {
		// Update angle
		this.cameraAnimation.angle += this.cameraAnimation.speed;

		// Calculate new x position with smooth sine wave
		const newX =
			this.cameraAnimation.basePosition.x +
			Math.sin(this.cameraAnimation.angle) * this.cameraAnimation.amplitude;

		// Update camera position
		this.camera.position.x = newX;

		// Adjust look-at position slightly for more natural movement
		const lookAtX =
			Math.sin(this.cameraAnimation.angle) *
			(this.cameraAnimation.amplitude / 4);
		this.camera.lookAt(
			lookAtX,
			this.cameraAnimation.lookAtPosition.y,
			this.cameraAnimation.lookAtPosition.z
		);
	}

	toggleCameraAnimation() {
		this.cameraAnimation.active = !this.cameraAnimation.active;
		if (!this.cameraAnimation.active) {
			// Reset to center position when turning off
			this.camera.position.x = this.cameraAnimation.basePosition.x;
			this.camera.lookAt(
				this.cameraAnimation.lookAtPosition.x,
				this.cameraAnimation.lookAtPosition.y,
				this.cameraAnimation.lookAtPosition.z
			);
		}
	}

	animate() {
		requestAnimationFrame(() => this.animate());
		const delta = this.clock.getDelta();
		this.update(delta);

		// Use composer instead of renderer if available
		if (this.composer) {
			this.composer.render();
		} else {
			this.renderer.render(this.scene, this.camera);
		}
	}
}

================
File: public/game/Level.js
================
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
import { Cube } from './Cube.js';

export class Level {
	constructor(game) {
		this.game = game;
		this.platform = [];
		this.cubes = [];
		this.waveIndex = 0;
		this.waveTime = 0;
		this.wavesRemaining = 0;

		// Platform properties
		this.platformMesh = null;
		this.platformWidth = 0;
		this.platformLength = 0;

		// Level state
		this.levelComplete = false;
		this.gameOver = false;
	}

	createPlatform() {
		const width = this.game.settings.stageWidth;
		const length = this.game.settings.stageLength;

		// Create grid texture
		const gridTexture = this.createGridTexture();

		// Create platform geometry
		const geometry = new THREE.BoxGeometry(width, 1, length);

		// Create material with grid texture
		const material = new THREE.MeshStandardMaterial({
			color: 0x0a0a2a,
			emissive: 0x0a0a2a,
			emissiveIntensity: 0.2,
			metalness: 0.8,
			roughness: 0.2,
			map: gridTexture,
		});

		// Create platform mesh
		this.platformMesh = new THREE.Mesh(geometry, material);
		this.platformMesh.position.set(0, -0.5, length / 2);
		this.platformMesh.receiveShadow = true;
		this.game.scene.add(this.platformMesh);

		// Add grid lines on top of platform for enhanced visual effect
		this.addGridLines(width, length);

		// Store dimensions
		this.platformWidth = width;
		this.platformLength = length;

		// Create platform grid for gameplay
		this.platform = [];

		for (let x = -Math.floor(width / 2); x <= Math.floor(width / 2); x++) {
			for (let z = 0; z < length; z++) {
				this.platform.push({ x, z, exists: true });
			}
		}
	}

	createGridTexture() {
		// Create a canvas for the grid texture
		const canvas = document.createElement('canvas');
		canvas.width = 512;
		canvas.height = 512;
		const context = canvas.getContext('2d');

		// Fill background
		context.fillStyle = '#0a0a2a';
		context.fillRect(0, 0, 512, 512);

		// Draw grid lines
		context.strokeStyle = '#0088ff';
		context.lineWidth = 1;

		// Draw vertical lines
		const cellSize = 32;
		for (let i = 0; i <= 512; i += cellSize) {
			context.beginPath();
			context.moveTo(i, 0);
			context.lineTo(i, 512);
			context.globalAlpha = i % (cellSize * 2) === 0 ? 0.5 : 0.2;
			context.stroke();
		}

		// Draw horizontal lines
		for (let i = 0; i <= 512; i += cellSize) {
			context.beginPath();
			context.moveTo(0, i);
			context.lineTo(512, i);
			context.globalAlpha = i % (cellSize * 2) === 0 ? 0.5 : 0.2;
			context.stroke();
		}

		// Create texture from canvas
		const texture = new THREE.CanvasTexture(canvas);
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(2, 8); // Repeat the texture to cover the platform

		return texture;
	}

	addGridLines(width, length) {
		// Create grid lines material
		const material = new THREE.LineBasicMaterial({
			color: 0x00aaff,
			transparent: true,
			opacity: 0.3,
		});

		// Create horizontal grid lines
		const horizontalStep = 1;
		for (let z = 0; z <= length; z += horizontalStep) {
			const points = [
				new THREE.Vector3(-width / 2, 0.01, z),
				new THREE.Vector3(width / 2, 0.01, z),
			];
			const geometry = new THREE.BufferGeometry().setFromPoints(points);
			const line = new THREE.Line(geometry, material);
			this.platformMesh.add(line);
		}

		// Create vertical grid lines
		const verticalStep = 1;
		for (let x = -width / 2; x <= width / 2; x += verticalStep) {
			const points = [
				new THREE.Vector3(x, 0.01, 0),
				new THREE.Vector3(x, 0.01, length),
			];
			const geometry = new THREE.BufferGeometry().setFromPoints(points);
			const line = new THREE.Line(geometry, material);
			this.platformMesh.add(line);
		}
	}

	generateLevel(levelNumber) {
		// Clear previous level
		this.clearLevel();

		// Calculate wave count based on level
		this.wavesRemaining = 2 + Math.min(levelNumber, 8);

		// Generate first wave
		this.generateWave();
	}

	generateWave() {
		if (this.wavesRemaining <= 0) {
			this.levelComplete = true;
			return;
		}

		this.wavesRemaining--;
		this.waveIndex++;

		// Wave properties based on level
		const cubeCount = this.game.settings.initialCubeCount;
		const width = this.game.settings.stageWidth;
		const level = this.game.currentLevel;

		// Calculate cube distribution
		let normalCount = Math.floor(cubeCount * 0.7); // 70% normal
		let forbiddenCount = Math.floor(cubeCount * 0.2); // 20% forbidden
		let advantageCount = Math.floor(cubeCount * 0.1); // 10% advantage

		// Ensure at least one of each type (for higher levels)
		if (level >= 2 && forbiddenCount === 0) forbiddenCount = 1;
		if (level >= 3 && advantageCount === 0) advantageCount = 1;

		// Create cubes
		const startZ = this.platformLength + 2; // Start beyond platform
		const halfWidth = Math.floor(width / 2);

		// Precalculate positions without duplicates
		const positions = [];
		for (let x = -halfWidth; x <= halfWidth; x++) {
			for (let z = startZ; z < startZ + 3; z++) {
				positions.push({ x, z });
			}
		}

		// Shuffle positions
		for (let i = positions.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[positions[i], positions[j]] = [positions[j], positions[i]];
		}

		// Place normal cubes
		for (let i = 0; i < normalCount && i < positions.length; i++) {
			const { x, z } = positions[i];
			this.createCube('normal', x, z);
		}

		// Place forbidden cubes
		for (
			let i = normalCount;
			i < normalCount + forbiddenCount && i < positions.length;
			i++
		) {
			const { x, z } = positions[i];
			this.createCube('forbidden', x, z);
		}

		// Place advantage cubes
		for (
			let i = normalCount + forbiddenCount;
			i < normalCount + forbiddenCount + advantageCount && i < positions.length;
			i++
		) {
			const { x, z } = positions[i];
			this.createCube('advantage', x, z);
		}
	}

	createCube(type, x, z) {
		const cube = new Cube(this.game, type, x, z);
		this.cubes.push(cube);
	}

	update(delta) {
		// Update cubes
		for (let i = this.cubes.length - 1; i >= 0; i--) {
			const cube = this.cubes[i];

			// Update cube
			cube.update(delta);

			// Check if cube fell off
			if (cube.mesh.position.z < -2) {
				// Handle cube falling off
				if (cube.type === 'normal') {
					// Player missed a normal cube
					// Potential penalty here
				}

				// Remove cube
				this.removeCube(cube);
			}
		}

		// Update wave timer
		this.waveTime += delta;

		// Generate new wave if needed
		if (this.cubes.length === 0 && this.wavesRemaining > 0) {
			this.generateWave();
		}
	}

	removeCube(cube) {
		// Add explosion effect
		this.createExplosionEffect(
			cube.mesh.position.x,
			cube.mesh.position.y,
			cube.mesh.position.z,
			cube.type
		);

		// Check if this is an advantage cube (green) to trigger chain reaction
		if (cube.type === 'advantage') {
			this.triggerChainReaction(cube);
		}

		// If this is a forbidden cube (black), shrink the platform
		if (cube.type === 'forbidden') {
			this.shrinkPlatform(3); // Remove 3 rows
		}

		// Remove cube from scene
		this.game.scene.remove(cube.mesh);

		// Remove from cubes array
		const index = this.cubes.indexOf(cube);
		if (index > -1) {
			this.cubes.splice(index, 1);
		}
	}

	triggerChainReaction(sourceCube) {
		// Get position of the source cube
		const pos = sourceCube.mesh.position;
		const x = Math.round(pos.x);
		const z = Math.round(pos.z);

		// Find cubes in adjacent positions (including diagonals)
		const affectedCubes = [];

		for (let i = 0; i < this.cubes.length; i++) {
			const cube = this.cubes[i];
			const cubeX = Math.round(cube.mesh.position.x);
			const cubeZ = Math.round(cube.mesh.position.z);

			// Check if the cube is adjacent (including diagonals)
			if (
				Math.abs(cubeX - x) <= 1 &&
				Math.abs(cubeZ - z) <= 1 &&
				cube !== sourceCube
			) {
				affectedCubes.push(cube);
			}
		}

		// Create a larger explosion for the chain reaction
		this.createChainExplosionEffect(x, pos.y, z);

		// Remove affected cubes with a slight delay for visual effect
		if (affectedCubes.length > 0) {
			setTimeout(() => {
				// Copy array to avoid modification issues during iteration
				const cubesToRemove = [...affectedCubes];

				cubesToRemove.forEach((cube) => {
					// Check if cube still exists (might have been removed by another chain)
					if (this.cubes.includes(cube)) {
						this.removeCube(cube);
					}
				});
			}, 150);
		}
	}

	createChainExplosionEffect(x, y, z) {
		// Create a green shockwave effect
		const segments = 32;
		const geometry = new THREE.RingGeometry(0, 2, segments);
		const material = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.7,
			side: THREE.DoubleSide,
		});

		const ring = new THREE.Mesh(geometry, material);
		ring.position.set(x, y, z);
		ring.rotation.x = Math.PI / 2; // Rotate to be horizontal
		this.game.scene.add(ring);

		// Create a bright flash light
		const light = new THREE.PointLight(0x00ff00, 3, 8);
		light.position.set(x, y, z);
		this.game.scene.add(light);

		// Animate the shockwave
		let scale = 0;
		const maxScale = 3;
		const animate = () => {
			scale += 0.2;

			// Scale the ring
			ring.scale.set(scale, scale, scale);

			// Fade the ring and light as they expand
			const opacity = 1 - scale / maxScale;
			material.opacity = opacity * 0.7;
			light.intensity = 3 * opacity;

			if (scale < maxScale) {
				requestAnimationFrame(animate);
			} else {
				// Remove ring and light from scene
				this.game.scene.remove(ring);
				this.game.scene.remove(light);
			}
		};

		// Start animation
		animate();
	}

	createExplosionEffect(x, y, z, cubeType) {
		// Create particles for explosion
		const particleCount = 15;
		const particles = new THREE.Group();

		// Different explosion effects based on cube type
		let color = 0xffffff; // Default white for normal cubes
		let scale = 1.0;
		let duration = 1.0;

		if (cubeType === 'advantage') {
			color = 0x00ff00; // Green for advantage cubes
			scale = 1.5;
			duration = 1.5;
		} else if (cubeType === 'forbidden') {
			color = 0xff0000; // Red for forbidden cubes
			scale = 1.2;
			duration = 1.2;
		}

		// Create particle material
		const particleMaterial = new THREE.MeshBasicMaterial({
			color: color,
			transparent: true,
			opacity: 1,
		});

		// Create particles
		for (let i = 0; i < particleCount; i++) {
			const size = (Math.random() * 0.2 + 0.1) * scale;
			const particleGeometry = new THREE.SphereGeometry(size, 6, 6);
			const particle = new THREE.Mesh(
				particleGeometry,
				particleMaterial.clone()
			);

			// Position at center of explosion
			particle.position.set(x, y, z);

			// Random velocity
			particle.userData.velocity = new THREE.Vector3(
				(Math.random() - 0.5) * 0.3 * scale,
				Math.random() * 0.5 * scale,
				(Math.random() - 0.5) * 0.3 * scale
			);

			// Add to group
			particles.add(particle);
		}

		// Add to scene
		this.game.scene.add(particles);

		// Create a light flash
		const light = new THREE.PointLight(color, 2, 5);
		light.position.set(x, y, z);
		this.game.scene.add(light);

		// Animation timer
		let timer = 0;
		const animate = () => {
			timer += 0.02;

			// Update particles
			particles.children.forEach((particle) => {
				// Move particle
				particle.position.add(particle.userData.velocity);

				// Apply gravity
				particle.userData.velocity.y -= 0.01;

				// Fade out
				particle.material.opacity = 1 - timer / duration;

				// Shrink slightly
				const scale = 1 - timer / duration;
				particle.scale.set(scale, scale, scale);
			});

			// Fade light
			light.intensity = 2 * (1 - timer / (duration * 0.5));

			if (timer < duration) {
				requestAnimationFrame(animate);
			} else {
				// Remove particles and light from scene
				this.game.scene.remove(particles);
				this.game.scene.remove(light);
			}
		};

		// Start animation
		animate();
	}

	clearLevel() {
		// Remove all cubes
		for (let i = this.cubes.length - 1; i >= 0; i--) {
			const cube = this.cubes[i];
			this.game.scene.remove(cube.mesh);
		}

		// Clear arrays
		this.cubes = [];

		// Reset state
		this.waveIndex = 0;
		this.waveTime = 0;
		this.levelComplete = false;
		this.gameOver = false;
	}

	extendPlatform() {
		// Add another row to the platform when level is completed
		const width = this.platformWidth;
		const newLength = this.platformLength + 1;

		// Update platform mesh
		this.game.scene.remove(this.platformMesh);

		const geometry = new THREE.BoxGeometry(width, 0.5, newLength);
		const material = new THREE.MeshLambertMaterial({
			color: 0x444444,
			emissive: 0x111111,
			emissiveIntensity: 0.2,
		});

		this.platformMesh = new THREE.Mesh(geometry, material);
		this.platformMesh.position.set(0, -0.25, newLength / 2 - 0.5);
		this.platformMesh.receiveShadow = true;

		this.game.scene.add(this.platformMesh);

		// Add new row to platform data
		for (let x = -Math.floor(width / 2); x <= Math.floor(width / 2); x++) {
			this.platform.push({ x, z: newLength - 1, exists: true });
		}

		// Update platform length
		this.platformLength = newLength;
	}

	shrinkPlatform(rowsToRemove = 3) {
		// Shrink platform by removing specified number of rows
		for (let r = 0; r < rowsToRemove; r++) {
			// Get the farthest row that still exists
			let maxRow = -1;
			for (let i = 0; i < this.platform.length; i++) {
				const tile = this.platform[i];
				if (tile.exists && tile.z > maxRow) {
					maxRow = tile.z;
				}
			}

			if (maxRow < 0) break; // No more rows to remove

			// Remove cubes on that row
			for (let i = this.cubes.length - 1; i >= 0; i--) {
				const cube = this.cubes[i];
				if (Math.round(cube.mesh.position.z) === maxRow) {
					this.removeCube(cube);
				}
			}

			// Mark tiles as non-existent
			for (let i = this.platform.length - 1; i >= 0; i--) {
				const tile = this.platform[i];
				if (tile.z === maxRow) {
					tile.exists = false;
				}
			}

			// Check if player is affected
			const playerPos = this.game.player.getPosition();
			if (Math.round(playerPos.z) === maxRow) {
				this.gameOver = true;
			}
		}

		// Update platform mesh visual (add a red glow effect to show danger)
		const redIntensity = Math.min(0.2 + rowsToRemove * 0.1, 0.5);
		this.platformMesh.material.emissive.set(0xff0000);
		this.platformMesh.material.emissiveIntensity = redIntensity;

		// Reset emissive color after a short delay
		setTimeout(() => {
			this.platformMesh.material.emissive.set(0x111111);
			this.platformMesh.material.emissiveIntensity = 0.2;
		}, 500);
	}

	isPlatformAt(x, z) {
		// Check if platform exists at this position
		for (const tile of this.platform) {
			if (tile.x === x && tile.z === z && tile.exists) {
				return true;
			}
		}
		return false;
	}

	getCubesAtPosition(x, z) {
		// Find all cubes at a specific position
		return this.cubes.filter((cube) => {
			// Use approximate position to handle moving cubes
			const cubeX = Math.round(cube.mesh.position.x);
			const cubeZ = Math.round(cube.mesh.position.z);

			return cubeX === Math.round(x) && cubeZ === Math.round(z);
		});
	}

	getRemainingCubes() {
		return this.cubes.filter((cube) => cube.type === 'normal').length;
	}

	isLevelComplete() {
		return this.levelComplete;
	}

	isGameOver() {
		return this.gameOver;
	}
}

================
File: public/game/main.js
================
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
import { Game } from './Game.js';

// Check if the user has paid
const checkPaymentStatus = async () => {
	try {
		const response = await fetch('/check-payment');
		const data = await response.json();
		return data.paid;
	} catch (error) {
		console.error('Error checking payment status:', error);
		return false;
	}
};

// Initialize the game
const initGame = async () => {
	// Check payment status
	const paid = await checkPaymentStatus();

	// Create game instance
	const game = new Game();

	// Set paid status
	game.paid = paid;

	// Check for success parameter in URL (for Stripe redirect)
	const urlParams = new URLSearchParams(window.location.search);
	if (urlParams.get('success') === 'true') {
		game.paid = true;
		// Remove query parameters
		window.history.replaceState({}, document.title, window.location.pathname);
	}

	// Start animation loop
	game.animate();
};

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', initGame);

================
File: public/game/PaymentModal.js
================
export class PaymentModal {
	constructor(game) {
		this.game = game;
		this.modal = document.getElementById('payment-modal');
		this.closeButton = document.querySelector('.close');
		this.payButton = document.getElementById('pay-button');

		// Add event listeners
		this.closeButton.addEventListener('click', () => this.hide());
		this.payButton.addEventListener('click', () => this.processPayment());

		// Load Stripe.js
		this.loadStripeScript();
	}

	show() {
		this.modal.style.display = 'block';
	}

	hide() {
		this.modal.style.display = 'none';
	}

	loadStripeScript() {
		if (!document.getElementById('stripe-js')) {
			const script = document.createElement('script');
			script.id = 'stripe-js';
			script.src = 'https://js.stripe.com/v3/';
			script.async = true;
			document.body.appendChild(script);
		}
	}

	async processPayment() {
		try {
			// Check if Stripe is loaded
			if (window.Stripe) {
				// Create a Stripe instance
				const stripe = Stripe('pk_test_TYooMQauvdEDq54NiTphI7jx');

				// Call backend to create checkout session
				const response = await fetch('/create-checkout-session', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						product: 'Quantum Grid: Neon Legacy Full Version',
					}),
				});

				const session = await response.json();

				// Redirect to checkout
				const result = await stripe.redirectToCheckout({
					sessionId: session.id,
				});

				if (result.error) {
					console.error(result.error.message);
					this.fallbackPayment();
				}
			} else {
				// If Stripe isn't loaded, use fallback
				this.fallbackPayment();
			}
		} catch (error) {
			console.error('Payment error:', error);
			this.fallbackPayment();
		}
	}

	fallbackPayment() {
		// Mock payment processing as fallback
		alert('Thank you for your purchase! Enjoy the full game!');

		// Hide modal
		this.hide();

		// Reset play count
		this.game.playCount = 0;

		// Continue to next level
		this.game.startLevel(this.game.currentLevel);
	}
}

================
File: public/game/Player.js
================
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

export class Player {
	constructor(game) {
		this.game = game;
		this.mesh = null;
		this.position = {
			x: 0,
			z: 0,
		};
		this.size = 0.3;
		this.moveSpeed = 0.2;
		this.lastMoveTime = 0;
		this.moveCooldown = 150; // ms
		this.isMoving = false;
		this.moveProgress = 0;
		this.startPosition = { x: 0, z: 0 };
		this.targetPosition = { x: 0, z: 0 };

		this.init();
	}

	init() {
		// Create player mesh
		this.createMesh();
	}

	createMesh() {
		// Create player geometry
		const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);

		// Create player material with neon effect
		const material = new THREE.MeshStandardMaterial({
			color: 0x00ffff,
			emissive: 0x00ffff,
			emissiveIntensity: 0.5,
			metalness: 0.8,
			roughness: 0.2,
		});

		// Create player mesh
		this.mesh = new THREE.Mesh(geometry, material);
		this.mesh.position.copy(this.position);
		this.mesh.castShadow = true;
		this.mesh.receiveShadow = true;

		// Add wireframe overlay for neon grid effect
		const wireframe = new THREE.LineSegments(
			new THREE.EdgesGeometry(geometry),
			new THREE.LineBasicMaterial({
				color: 0xffffff,
				linewidth: 2,
			})
		);
		this.mesh.add(wireframe);

		// Add glow effect
		this.addGlowEffect();

		// Add to scene
		this.game.scene.add(this.mesh);
	}

	addGlowEffect() {
		// Create a point light that follows the player
		this.glowLight = new THREE.PointLight(0x00ffff, 0.8, 3);
		this.glowLight.position.set(0, 0, 0);
		this.mesh.add(this.glowLight);

		// Create a pulse animation for the glow
		this.glowPulse = {
			intensity: 0.8,
			min: 0.5,
			max: 1.0,
			speed: 2.0,
			direction: 1,
		};
	}

	resetPosition() {
		// Place player at the start of the platform
		const stageWidth = this.game.settings.stageWidth;
		const stageLength = this.game.settings.stageLength;

		this.position.x = 0;
		this.position.z = 1; // Near the start

		this.updateMeshPosition();
	}

	updateMeshPosition() {
		if (this.mesh) {
			this.mesh.position.set(
				this.position.x,
				this.size * 0.7, // Half height + small gap
				this.position.z
			);
		}
	}

	move(direction) {
		// Prevent rapid movement
		const now = Date.now();
		if (now - this.lastMoveTime < this.moveCooldown) {
			return;
		}
		this.lastMoveTime = now;

		// Get current position
		const { x, z } = this.position;
		const stageWidth = this.game.settings.stageWidth;
		const stageLength = this.game.settings.stageLength;

		// Calculate new position based on direction
		let newX = x;
		let newZ = z;

		switch (direction) {
			case 'forward':
				newZ = z + 1;
				break;
			case 'backward':
				newZ = z - 1;
				break;
			case 'left':
				newX = x - 1;
				break;
			case 'right':
				newX = x + 1;
				break;
		}

		// Check boundaries
		const halfWidth = Math.floor(stageWidth / 2);
		if (newX < -halfWidth || newX > halfWidth) {
			return;
		}

		if (newZ < 0 || newZ >= stageLength) {
			return;
		}

		// Check if the platform exists at this position
		if (!this.game.level.isPlatformAt(newX, newZ)) {
			return;
		}

		// Move player
		this.position.x = newX;
		this.position.z = newZ;

		// Update mesh position
		this.updateMeshPosition();
	}

	getPosition() {
		return {
			x: this.position.x,
			z: this.position.z,
		};
	}

	update(delta) {
		// Handle movement animation
		if (this.isMoving) {
			this.moveProgress += this.moveSpeed * delta;

			if (this.moveProgress >= 1) {
				// Movement complete
				this.position.copy(this.targetPosition);
				this.isMoving = false;
				this.moveProgress = 0;
			} else {
				// Interpolate position
				this.position.lerpVectors(
					this.startPosition,
					this.targetPosition,
					this.moveProgress
				);
			}

			// Update mesh position
			this.updateMeshPosition();
		}

		// Update glow pulse effect
		this.updateGlowEffect(delta);
	}

	updateGlowEffect(delta) {
		// Pulse the glow light intensity
		this.glowPulse.intensity +=
			this.glowPulse.direction * this.glowPulse.speed * delta;

		// Reverse direction at min/max
		if (this.glowPulse.intensity >= this.glowPulse.max) {
			this.glowPulse.intensity = this.glowPulse.max;
			this.glowPulse.direction = -1;
		} else if (this.glowPulse.intensity <= this.glowPulse.min) {
			this.glowPulse.intensity = this.glowPulse.min;
			this.glowPulse.direction = 1;
		}

		// Apply the new intensity
		this.glowLight.intensity = this.glowPulse.intensity;
	}
}

================
File: public/game/UI.js
================
export class UI {
	constructor(game) {
		this.game = game;

		// Get UI elements
		this.scoreElement = document.getElementById('score');
		this.levelElement = document.getElementById('level');
		this.cubesLeftElement = document.getElementById('cubes-left');
		this.livesElement = document.getElementById('lives');

		// Get screen elements
		this.startScreen = document.getElementById('start-screen');
		this.gameOverScreen = document.getElementById('game-over');
		this.finalScoreElement = document.getElementById('final-score');

		// Get buttons
		this.startButton = document.getElementById('start-button');
		this.restartButton = document.getElementById('restart-button');

		// Payment modal
		this.paymentModal = document.getElementById('payment-modal');
		this.paymentButtonContainer = document.getElementById(
			'payment-button-container'
		);

		// Initialize event listeners
		this.initEventListeners();
	}

	initEventListeners() {
		// Start button
		this.startButton.addEventListener('click', () => {
			this.hideStartScreen();
			this.game.startGame();
		});

		// Restart button
		this.restartButton.addEventListener('click', () => {
			this.hideGameOverScreen();
			this.game.restartGame();
		});
	}

	updateScore(score) {
		this.scoreElement.textContent = `Score: ${score}`;
	}

	updateLevel(level) {
		this.levelElement.textContent = `Level: ${level}`;
	}

	updateCubesLeft(count) {
		this.cubesLeftElement.textContent = `Cubes: ${count}`;
	}

	updateLives(lives) {
		if (this.livesElement) {
			// Clear previous hearts
			this.livesElement.innerHTML = '';

			// Add heart icons for each life
			for (let i = 0; i < lives; i++) {
				const heartIcon = document.createElement('span');
				heartIcon.className = 'heart-icon';
				heartIcon.innerHTML = '❤️';
				this.livesElement.appendChild(heartIcon);
			}

			// Add empty hearts for lost lives
			for (let i = lives; i < 3; i++) {
				const emptyHeartIcon = document.createElement('span');
				emptyHeartIcon.className = 'heart-icon empty';
				emptyHeartIcon.innerHTML = '🖤';
				this.livesElement.appendChild(emptyHeartIcon);
			}
		}
	}

	showGameOverScreen(finalScore) {
		this.finalScoreElement.textContent = finalScore;
		this.gameOverScreen.style.display = 'flex';
	}

	hideGameOverScreen() {
		this.gameOverScreen.style.display = 'none';
	}

	showStartScreen() {
		this.startScreen.style.display = 'flex';
	}

	hideStartScreen() {
		this.startScreen.style.display = 'none';
	}

	showPaymentModal() {
		this.paymentModal.style.display = 'flex';

		// Clear previous buttons
		this.paymentButtonContainer.innerHTML = '';

		// Initialize Stripe payment button
		if (this.game.stripe) {
			const checkoutButton = document.createElement('button');
			checkoutButton.id = 'checkout-button';
			checkoutButton.textContent = 'Unlock Full Game - $2.99';
			this.paymentButtonContainer.appendChild(checkoutButton);

			checkoutButton.addEventListener('click', () => {
				this.game.handlePayment();
			});
		}

		// Add cancel button
		const cancelButton = document.createElement('button');
		cancelButton.id = 'cancel-payment-button';
		cancelButton.textContent = 'Cancel';
		cancelButton.style.backgroundColor = 'transparent';
		cancelButton.style.color = '#ccc';
		cancelButton.style.border = '2px solid #ccc';
		this.paymentButtonContainer.appendChild(cancelButton);

		// Add event listener to cancel button
		cancelButton.addEventListener('click', () => {
			this.hidePaymentModal();
			this.hideGameOverScreen();
			this.game.restartGame();
		});
	}

	hidePaymentModal() {
		this.paymentModal.style.display = 'none';

		// Clear payment button container
		while (this.paymentButtonContainer.firstChild) {
			this.paymentButtonContainer.removeChild(
				this.paymentButtonContainer.firstChild
			);
		}
	}
}

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Quantum Grid: Neon Legacy</title>
		<link rel="icon" href="/favicon.ico" />
		<link
			href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
			rel="stylesheet"
		/>
		<!-- Post-processing libraries -->
		<script
			type="module"
			src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/EffectComposer.js"
		></script>
		<script
			type="module"
			src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/RenderPass.js"
		></script>
		<script
			type="module"
			src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/UnrealBloomPass.js"
		></script>
		<script
			type="module"
			src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/ShaderPass.js"
		></script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				font-family: 'Orbitron', sans-serif;
				background-color: #000;
				color: #fff;
			}
			canvas {
				display: block;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				color: #0cf;
				z-index: 100;
				pointer-events: none;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#score {
				position: absolute;
				top: 10px;
				left: 10px;
				color: #fff;
				z-index: 100;
				pointer-events: none;
				font-size: 18px;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#level {
				position: absolute;
				top: 40px;
				left: 10px;
				color: #fff;
				z-index: 100;
				pointer-events: none;
				font-size: 18px;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#cubes-left {
				position: absolute;
				top: 70px;
				left: 10px;
				color: #fff;
				z-index: 100;
				pointer-events: none;
				font-size: 18px;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#lives {
				position: absolute;
				top: 100px;
				left: 10px;
				color: #fff;
				z-index: 100;
				pointer-events: none;
				font-size: 22px;
			}
			.heart-icon {
				margin-right: 5px;
				animation: pulse 1.5s infinite ease-in-out;
			}
			.heart-icon.empty {
				opacity: 0.4;
				animation: none;
			}
			@keyframes pulse {
				0% {
					transform: scale(1);
				}
				50% {
					transform: scale(1.1);
				}
				100% {
					transform: scale(1);
				}
			}
			#controls {
				position: absolute;
				bottom: 10px;
				width: 100%;
				text-align: center;
				color: #fff;
				z-index: 100;
				pointer-events: none;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#payment-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.8);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 30;
				backdrop-filter: blur(5px);
			}
			#payment-container {
				background-color: rgba(10, 10, 42, 0.9);
				padding: 30px;
				border-radius: 10px;
				max-width: 500px;
				width: 90%;
				text-align: center;
				border: 2px solid #00ffff;
				box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
			}
			#payment-container h2 {
				color: #fff;
				margin-top: 0;
				text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
			}
			#payment-container p {
				margin-bottom: 20px;
				color: #ccc;
			}
			#gameOverScreen {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.7);
				z-index: 1000;
				color: white;
				text-align: center;
				opacity: 0;
				transition: opacity 0.5s ease;
				font-family: 'Orbitron', sans-serif;
			}
			#gameOverScreen.active {
				opacity: 1;
			}
			#gameOverScreen div {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}
			#gameOverScreen h1 {
				font-size: 42px;
				margin-bottom: 20px;
				color: #ff3366;
				text-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
			}
			#gameOverScreen button {
				padding: 10px 20px;
				background-color: #0cf;
				color: #001428;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				margin-top: 20px;
				font-size: 18px;
				font-family: 'Orbitron', sans-serif;
				font-weight: bold;
				transition: all 0.2s ease;
			}
			#gameOverScreen button:hover {
				background-color: #00e6ff;
				box-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
				transform: scale(1.05);
			}
			#markedTile {
				position: absolute;
				bottom: 40px;
				right: 10px;
				color: #fff;
				z-index: 100;
				font-size: 18px;
				text-shadow: 0 0 10px rgba(0, 204, 255, 0.7);
			}
			#tutorial {
				display: none;
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background-color: rgba(0, 20, 40, 0.9);
				border: 2px solid #0cf;
				padding: 30px;
				border-radius: 5px;
				width: 500px;
				color: #fff;
				z-index: 2000;
				box-shadow: 0 0 20px rgba(0, 204, 255, 0.5);
				text-align: center;
				font-family: 'Orbitron', sans-serif;
			}
			#tutorial h2 {
				color: #0cf;
				margin-top: 0;
			}
			.cube-info {
				display: flex;
				justify-content: space-between;
				margin: 20px 0;
			}
			.cube-info div {
				text-align: center;
				flex: 1;
			}
			.cube-icon {
				display: inline-block;
				width: 30px;
				height: 30px;
				margin-bottom: 5px;
			}
			.normal-cube {
				background-color: #aaa;
			}
			.forbidden-cube {
				background-color: #000;
				border: 1px solid #333;
			}
			.advantage-cube {
				background-color: #0f0;
			}
			.key-info {
				display: flex;
				flex-wrap: wrap;
				justify-content: center;
				margin-top: 20px;
			}
			.key-item {
				margin: 5px 10px;
			}
			.key {
				display: inline-block;
				padding: 5px 10px;
				background-color: #001428;
				border: 1px solid #0cf;
				border-radius: 3px;
				margin-right: 5px;
			}
			#ui {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				padding: 20px;
				box-sizing: border-box;
				pointer-events: none;
				z-index: 10;
			}
			#score-container {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 10px;
			}
			#score,
			#level {
				font-size: 24px;
				font-weight: bold;
				text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
				color: #fff;
			}
			#game-over,
			#start-screen {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				background-color: rgba(0, 0, 0, 0.8);
				z-index: 20;
			}
			#game-over h1,
			#start-screen h1 {
				font-size: 48px;
				margin-bottom: 20px;
				text-align: center;
				text-transform: uppercase;
				letter-spacing: 3px;
				color: #fff;
				text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff;
				animation: neon-pulse 1.5s infinite alternate;
			}
			#game-over p,
			#start-screen p {
				font-size: 24px;
				margin-bottom: 30px;
				text-align: center;
				max-width: 600px;
				color: #ccc;
			}
			button {
				font-family: 'Orbitron', sans-serif;
				font-size: 18px;
				padding: 12px 30px;
				background-color: transparent;
				color: #00ffff;
				border: 2px solid #00ffff;
				border-radius: 4px;
				cursor: pointer;
				transition: all 0.3s;
				text-transform: uppercase;
				letter-spacing: 2px;
				margin: 10px;
				pointer-events: auto;
				position: relative;
				overflow: hidden;
				box-shadow: 0 0 10px #00ffff, 0 0 20px rgba(0, 255, 255, 0.5);
			}
			button:hover {
				background-color: rgba(0, 255, 255, 0.2);
				box-shadow: 0 0 15px #00ffff, 0 0 30px rgba(0, 255, 255, 0.7);
				transform: translateY(-2px);
			}
			button:active {
				transform: translateY(1px);
			}
			#instructions {
				position: absolute;
				bottom: 20px;
				left: 20px;
				background-color: rgba(0, 0, 0, 0.7);
				padding: 15px;
				border-radius: 5px;
				border: 1px solid #00ffff;
				box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
				max-width: 300px;
				pointer-events: auto;
			}
			#instructions h3 {
				margin-top: 0;
				color: #00ffff;
				text-shadow: 0 0 5px #00ffff;
			}
			#instructions p {
				margin: 5px 0;
				font-size: 14px;
			}
			.cube-type {
				display: flex;
				align-items: center;
				margin-bottom: 5px;
			}

			.cube-color {
				width: 15px;
				height: 15px;
				margin-right: 10px;
				border: 1px solid #fff;
			}

			.red {
				background-color: #ff0000;
				box-shadow: 0 0 5px #ff0000;
			}
			.green {
				background-color: #00ff00;
				box-shadow: 0 0 5px #00ff00;
			}
			.blue {
				background-color: #0000ff;
				box-shadow: 0 0 5px #0000ff;
			}
			.yellow {
				background-color: #ffff00;
				box-shadow: 0 0 5px #ffff00;
			}
			.black {
				background-color: #000;
				border: 1px solid #ff00ff;
				box-shadow: 0 0 5px #ff00ff;
			}

			@keyframes neon-pulse {
				from {
					text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff;
				}
				to {
					text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff,
						0 0 20px #ff00ff, 0 0 35px #ff00ff;
				}
			}
		</style>
	</head>
	<body>
		<div id="ui">
			<div id="score-container">
				<div id="score">Score: 0</div>
				<div id="level">Level: 1</div>
			</div>
		</div>

		<div id="instructions">
			<h3>Controls</h3>
			<p>WASD or Arrow Keys: Move</p>
			<p>Space: Mark/Capture Cube</p>
			<p>C: Toggle Camera Animation</p>

			<h3>Cube Types</h3>
			<div class="cube-type">
				<div class="cube-color red"></div>
				<p>Red: Regular cube</p>
			</div>
			<div class="cube-type">
				<div class="cube-color green"></div>
				<p>Green: Chain reaction</p>
			</div>
			<div class="cube-type">
				<div class="cube-color blue"></div>
				<p>Blue: Extra points</p>
			</div>
			<div class="cube-type">
				<div class="cube-color yellow"></div>
				<p>Yellow: Speed boost</p>
			</div>
			<div class="cube-type">
				<div class="cube-color black"></div>
				<p>Black: Shrinks platform</p>
			</div>
		</div>

		<div id="start-screen">
			<h1>Quantum Grid: Neon Legacy</h1>
			<p>
				Navigate the quantum grid and capture cubes before they fall off the
				edge. Avoid black cubes and use green cubes strategically for chain
				reactions.
			</p>
			<button id="start-button">Start Game</button>
		</div>

		<div id="game-over" style="display: none">
			<h1>Game Over</h1>
			<p>Your final score: <span id="final-score">0</span></p>
			<button id="restart-button">Play Again</button>
		</div>

		<div id="payment-modal" style="display: none">
			<div id="payment-container">
				<h2>Continue Your Quantum Journey</h2>
				<p>
					You've completed your free play session! Unlock the full experience to
					continue your journey through the quantum grid.
				</p>
				<div id="payment-button-container"></div>
			</div>
		</div>

		<div id="info">Quantum Grid: Neon Legacy</div>
		<div id="cubes-left">Cubes: 0</div>
		<div id="lives"></div>
		<div id="markedTile">No tile marked</div>
		<div id="controls">
			<p>
				WASD to move | Space to mark/capture | R to activate advantage | ESC to
				pause
			</p>
		</div>
		<div id="tutorial">
			<h2>Quantum Grid: Neon Legacy</h2>
			<p>
				Welcome to the grid! Survive as long as possible by capturing the right
				cubes.
			</p>

			<div class="cube-info">
				<div>
					<div class="cube-icon normal-cube"></div>
					<p>Normal Cube</p>
					<p>Capture for points</p>
				</div>
				<div>
					<div class="cube-icon forbidden-cube"></div>
					<p>Forbidden Cube</p>
					<p>Shrinks platform if captured</p>
				</div>
				<div>
					<div class="cube-icon advantage-cube"></div>
					<p>Advantage Cube</p>
					<p>Creates chain reactions</p>
				</div>
			</div>

			<div class="key-info">
				<div class="key-item"><span class="key">W</span> Move Up</div>
				<div class="key-item"><span class="key">A</span> Move Left</div>
				<div class="key-item"><span class="key">S</span> Move Down</div>
				<div class="key-item"><span class="key">D</span> Move Right</div>
				<div class="key-item"><span class="key">Space</span> Mark/Capture</div>
				<div class="key-item">
					<span class="key">R</span> Activate Advantage
				</div>
			</div>

			<p>You have 3 lives. Complete levels to extend the platform!</p>
			<p>(Press any key to start)</p>
		</div>

		<!-- Load Stripe.js -->
		<script src="https://js.stripe.com/v3/"></script>
		<script type="module" src="/game/main.js"></script>
	</body>
</html>

================
File: public/main.js
================
import { Game } from './game/Game.js';

// Initialize game
const game = new Game();
game.init();
game.animate();

// Export game instance for debugging
window.game = game;

================
File: public/success.html
================
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Payment Successful - Quantum Grid: Neon Legacy</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				font-family: Arial, sans-serif;
				background-color: #0c0c14;
				color: #ffffff;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				height: 100vh;
				text-align: center;
			}
			.container {
				max-width: 800px;
				padding: 2rem;
				border-radius: 8px;
				background-color: rgba(20, 20, 40, 0.7);
				box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
			}
			h1 {
				color: #00ffff;
				font-size: 2.5rem;
				margin-bottom: 1rem;
			}
			p {
				font-size: 1.2rem;
				line-height: 1.6;
				margin-bottom: 1.5rem;
			}
			.btn {
				display: inline-block;
				background-color: #00cc99;
				color: #000;
				padding: 0.8rem 1.5rem;
				border-radius: 4px;
				text-decoration: none;
				font-weight: bold;
				font-size: 1.1rem;
				transition: all 0.3s ease;
			}
			.btn:hover {
				background-color: #00ffaa;
				transform: translateY(-3px);
				box-shadow: 0 5px 15px rgba(0, 255, 170, 0.3);
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>Payment Successful!</h1>
			<p>Thank you for purchasing Quantum Grid: Neon Legacy!</p>
			<p>You now have full access to all game features and levels.</p>
			<p>Get ready to experience the complete quantum puzzle adventure!</p>
			<a href="/" class="btn">Return to Game</a>
		</div>
	</body>
</html>

================
File: README.md
================
# Quantum Grid: Neon Legacy

A 3D puzzle game inspired by the classic PlayStation game I.Q.: Intelligent Qube. Control a character on a quantum platform and capture cubes before they fall off the edge.

> **Developer's Note**: This game is a "one shot" - a complete gaming experience built to showcase the core gameplay loop. Escape into a neon-infused world where strategy meets quick reflexes!

## Game Rules

- **Normal Cubes (Gray)**: Capture these before they fall off
- **Forbidden Cubes (Black)**: Do NOT capture these - they shrink your platform
- **Advantage Cubes (Green)**: Capture and use these to clear 3x3 areas

## Features

- Multiple levels with increasing difficulty
- Dynamic gameplay with three cube types
- Special effects for cube captures
- Score tracking and game progression
- Neon aesthetic with modern visuals
- Infinitely generated levels

## Controls

- **WASD or Arrow Keys**: Move player
- **Space**: Mark/capture cube
- **R**: Activate advantage cube (3x3 area clear)
- **ESC**: Pause game

## Installation

1. Clone this repository:

   ```
   git clone https://github.com/yourusername/quantum-grid-neon-legacy.git
   ```

2. Install dependencies:

   ```
   npm install
   ```

3. Start the server:

   ```
   npm start
   ```

4. Open your browser and navigate to:
   ```
   http://localhost:3000
   ```

## Technologies Used

- Three.js for 3D rendering
- Express for serving the application
- Node.js as the runtime environment

## Game Strategy

1. Focus on capturing normal cubes while avoiding forbidden ones
2. Use advantage cubes strategically to clear areas with many normal cubes
3. Plan your movements carefully as the platform can shrink

## Project Structure

```
quantum-grid-neon-legacy/
├── package.json
├── server.js
└── public/
    ├── index.html
    ├── main.js
    └── game/
        ├── Game.js
        ├── Player.js
        ├── Level.js
        ├── Cube.js
        ├── UI.js
        └── PaymentModal.js
```

================
File: server.js
================
const express = require('express');
const path = require('path');
require('dotenv').config();
const app = express();
const PORT = process.env.PORT || 3000;

// Add Stripe integration
const stripe = process.env.STRIPE_SECRET_KEY
	? require('stripe')(process.env.STRIPE_SECRET_KEY)
	: null;

// Middleware to parse JSON bodies
app.use(express.json());

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));

// Root route
app.get('/', (req, res) => {
	res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Stripe payment endpoint
if (stripe) {
	app.post('/create-checkout-session', async (req, res) => {
		try {
			const session = await stripe.checkout.sessions.create({
				payment_method_types: ['card'],
				line_items: [
					{
						price_data: {
							currency: 'usd',
							product_data: {
								name: 'Quantum Grid: Neon Legacy Full Version',
							},
							unit_amount: 299, // $2.99
						},
						quantity: 1,
					},
				],
				mode: 'payment',
				success_url: `${req.headers.origin}/success.html`,
				cancel_url: `${req.headers.origin}/`,
			});
			res.json({ id: session.id });
		} catch (error) {
			console.error('Stripe error:', error);
			res.status(500).json({ error: error.message });
		}
	});
}

// Handle 404 errors for any other routes
app.use((req, res) => {
	console.log(`404 Not Found: ${req.originalUrl}`);
	res.status(404).send('404 Not Found');
});

app.listen(PORT, () => {
	console.log(`Quantum Grid: Neon Legacy running on port ${PORT}`);
});
